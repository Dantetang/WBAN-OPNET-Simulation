/* Process model C form file: wpan_gts_traffic_source.pr.c */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_gts_traffic_source.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_gts_traffic_source_pr_c [] = "MIL_3_Tfile_Hdr_ 150A 30A op_runsim_dev 7 4B067784 4B067784 1 nb-pju jurcikp 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files					*/
// Distribution Modeling sub-package
#include <oms_dist_support.h>
#include "headers\wpan_math.h"
#include "headers\wpan_params.h"

/* Interrupt code values			*/
//The same value should be in the wpan_mac Module for remote process
#define START_GTS_TRAFFIC 220
#define STOP_GTS_TRAFFIC 221

#define GENERATE 1


/* State machine conditions 		*/
#define	STOP			((op_intrpt_type() == OPC_INTRPT_REMOTE) && (op_intrpt_code() == STOP_GTS_TRAFFIC))
#define MSDU_GENERATE	((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code() == GENERATE))


/* Function prototypes.				*/
static void wpan_gts_source_init (void); 
static void wpan_gts_traffic_generate (void);
static void wpan_gts_interrupt_process (void);
static void wpan_gts_print_parameters (void);


/* Input and output streams		*/
#define	STRM_FROM_GTS_TO_MAC	0

/* Global variables.				*/
int app_sent_gts_msdu_nbr; // Number of GTS MSDU generated by the Application Layer
double app_sent_gts_msdu_bits; // GTS MSDUs sent by the Application Layer [kbits]

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	OmsT_Dist_Handle	       		msdu_interarrival_dist_ptr                      ;	/* PDF used to determine the interarrival time between two */
	                        		                                                	/* consecutive MSDUs (MAC frame payload).                  */
	OmsT_Dist_Handle	       		msdu_size_dist_ptr                              ;	/* PDF used to determine the sizes of generated */
	                        		                                                	/* MSDU (MAC frame payload).                    */
	char	                   		msdu_interarrival_dist_str[128]                 ;	/* The MSDU interarrival times. */
	char	                   		msdu_size_dist_str[128]                         ;	/* The size of generated MSDUs. */
	Boolean	                		acknowledgement                                 ;	/* Is the acknowledgement required? */
	char	                   		node_name[12]                                   ;	/* Name of the node. */
	Evhandle	               		next_msdu_evh                                   ;	/* Event handle of the next arriving MSDU. */
	Objid	                  		parent_id                                       ;	/* Object ID of the parent object (node). */
	Boolean	                		enable_log                                      ;	/* Is the logging to the file enabled? */
	Stathandle	             		bits_sent_hndl                                  ;	/* Statistic handle for "Traffic sent (bits/sec)" statistic. */
	Stathandle	             		bits_sent_hndlG                                 ;	/* Statistic handle for "Traffic Sent (bits/sec)" statistic - global. */
	Stathandle	             		msdus_sent_hndl                                 ;	/* Statistic handle for "Traffic Sent (MSDUs/sec)" statistic. */
	Stathandle	             		msdu_size_hndl                                  ;	/* Statistic handle for "MSDU Size (bits)" statistic. */
	Stathandle	             		msdu_interarrival_time_hndl                     ;	/* Statistic handle for "MSDU Interarrival Time (secs)" statistic. */
	Stathandle	             		msdus_hndl                                      ;	/* Statistic handle for the total number of generated MSDUs. */
	Stathandle	             		msdus_hndlG                                     ;
	} wpan_gts_traffic_source_state;

#define msdu_interarrival_dist_ptr		op_sv_ptr->msdu_interarrival_dist_ptr
#define msdu_size_dist_ptr      		op_sv_ptr->msdu_size_dist_ptr
#define msdu_interarrival_dist_str		op_sv_ptr->msdu_interarrival_dist_str
#define msdu_size_dist_str      		op_sv_ptr->msdu_size_dist_str
#define acknowledgement         		op_sv_ptr->acknowledgement
#define node_name               		op_sv_ptr->node_name
#define next_msdu_evh           		op_sv_ptr->next_msdu_evh
#define parent_id               		op_sv_ptr->parent_id
#define enable_log              		op_sv_ptr->enable_log
#define bits_sent_hndl          		op_sv_ptr->bits_sent_hndl
#define bits_sent_hndlG         		op_sv_ptr->bits_sent_hndlG
#define msdus_sent_hndl         		op_sv_ptr->msdus_sent_hndl
#define msdu_size_hndl          		op_sv_ptr->msdu_size_hndl
#define msdu_interarrival_time_hndl		op_sv_ptr->msdu_interarrival_time_hndl
#define msdus_hndl              		op_sv_ptr->msdus_hndl
#define msdus_hndlG             		op_sv_ptr->msdus_hndlG

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_gts_traffic_source_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_gts_traffic_source_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*********************************************************************************
 * The GTS traffic source can produce unacknowledged or acknowledged time critical 
 * MSDUs (MAC Service Dat Units = MAC Frame Payload) using the GTS mechanism.
**********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_source_init
 *
 * Description:	- initialize the process
 *				- read the values of source attributes
 *              - schedule a self interrupt that will indicate start time	
 *				  for MAC frame payload (i.e. MSDU) generation
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_gts_source_init() {
	
	Objid own_id;	/* Object ID of the surrounding processor or queue */
	Objid traffic_setting_comp_id; 
	Objid traffic_setting_id;
	char device_mode[20];	/* mode of the device: PAN Coordinator or End Device */

	/* Stack tracing enrty point */
	FIN(wpan_gts_source_init);

	
	/* obtain self object ID of the surrounding processor or queue */
	own_id = op_id_self ();

	/* obtain object ID of the parent object (node) */
	parent_id = op_topo_parent (own_id);	
		
	/* get the name of the node */
	op_ima_obj_attr_get (parent_id, "name", node_name);
	
	/* get the value to check if this node is PAN Coordinator or not */
	op_ima_obj_attr_get (parent_id, "Device Mode", &device_mode);
	
	
	op_ima_obj_attr_get (own_id, "GTS Traffic Parameters", &traffic_setting_id); 
	traffic_setting_comp_id = op_topo_child (traffic_setting_id, OPC_OBJTYPE_GENERIC, 0);
	
	/* Read the actual values of the MSDU parameters, i.e. the attribute values of the surrounding module. */
	op_ima_obj_attr_get (traffic_setting_comp_id, "MSDU Interarrival Time", msdu_interarrival_dist_str);
	op_ima_obj_attr_get (traffic_setting_comp_id, "MSDU Size",              msdu_size_dist_str);
	op_ima_obj_attr_get (traffic_setting_comp_id, "Acknowledgement",        &acknowledgement);	
	
	/* Load the PDFs that will be used in computing the MSDU interarrival times and MSDU size. */
	msdu_interarrival_dist_ptr = oms_dist_load_from_string (msdu_interarrival_dist_str);
	msdu_size_dist_ptr = oms_dist_load_from_string (msdu_size_dist_str);
						  
	op_ima_obj_attr_get (parent_id, "Enable Logging", &enable_log);		
	
	if (strcmp(device_mode, "PAN Coordinator")!=0)
		wpan_gts_print_parameters ();	/* only for the End Devices */
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	 wpan_gts_print_parameters
 *
 * Description:	print the setting GTS parameters
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_gts_print_parameters() {

	/* Stack tracing enrty point */
	FIN(wpan_gts_print_parameters);

	if (enable_log) {
		printf ("|----- [GTS TRAFFIC SOURCE PARAMETERS - NODE \"%s\"] -----------------------|\n", node_name);
		printf ("\t MSDU Interarrival Time (PDF) : %s\n", msdu_interarrival_dist_str);
		printf ("\t MSDU (MAC Frame Payload) Size (PDF) : %s\n", msdu_size_dist_str);	
		printf ("\t With Acknowledgement? : %s\n", boolean2string(acknowledgement));
		printf ("|-----------------------------------------------------------------------------|\n\n");
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_traffic_generate
 *
 * Description:	creates data unit (MSDU) presenting GTS (time critical) traffic based on the		
 *				 specifications of the source model and sends it to the lower layer.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_gts_traffic_generate() {

	Ici * iciptr;
	Packet*	msdu_ptr;
	int msdu_size; /* size in bits */
	double next_intarr_time;	/* interarrival time of next MSDU */
	double abs_next_intarr_time; /* absolute interarrival time of next MSDU */

	/* stack tracing enrty point */
	FIN (wpan_gts_traffic_generate());
	
	iciptr = op_ici_create ("wpan_gts_traffic_ici_format");
	op_ici_attr_set (iciptr, "Acknowledgement", acknowledgement);
	
	/* Generate a MSDU size outcome.	*/
	msdu_size = (int) ceil (oms_dist_outcome (msdu_size_dist_ptr));
	
	/* 0 <= msdu_size <= aMaxMACFrameSize_Bits (=(aMaxPHYPacketSize_Bits-MAC_HEADER_SIZE)) */
	if (msdu_size > aMaxMACFrameSize_Bits)
		msdu_size = aMaxMACFrameSize_Bits;	/* The size of generated MAC frame payload (MSDU) is bigger than the maximum - the size is set to the maximum. */
		
	if (msdu_size < 0)
		msdu_size = 0;
	
	/* We produce unformatted data packets. Create one.	*/
	msdu_ptr = op_pk_create (msdu_size);
	
	/* schedule next MSDU generation */
	next_intarr_time = oms_dist_outcome (msdu_interarrival_dist_ptr);
	
	/* Make sure that interarrival time is not negative. In that case it will be set to 0. */
	if (next_intarr_time < 0)
		next_intarr_time = 0.0;

	/* absolute interarrival time of next MSDU */
	abs_next_intarr_time = op_sim_time () + next_intarr_time;
	
	next_msdu_evh = op_intrpt_schedule_self (abs_next_intarr_time, GENERATE);
		
	/* Update the MSDU generation statistics */
	op_stat_write (msdus_sent_hndl, 1.0);
	op_stat_write (msdus_sent_hndl, 0.0);
	op_stat_write (bits_sent_hndl, (double) msdu_size);
	op_stat_write (bits_sent_hndl, 0.0);
	op_stat_write (bits_sent_hndlG, (double) msdu_size);
	op_stat_write (bits_sent_hndlG, 0.0);
	op_stat_write (msdu_size_hndl, (double) msdu_size);
	op_stat_write (msdu_interarrival_time_hndl, next_intarr_time);
	op_stat_write (msdus_hndl, 1.0);
	op_stat_write (msdus_hndlG, 1.0);
	
	app_sent_gts_msdu_bits = app_sent_gts_msdu_bits + (msdu_size/1000.0);	
	app_sent_gts_msdu_nbr = app_sent_gts_msdu_nbr + 1;		
		
	/* send the MSDU (MAC frame payload) via the stream to the lower layer (MAC layer).	*/
	op_ici_install (iciptr);
	op_pk_send (msdu_ptr, STRM_FROM_GTS_TO_MAC);
	op_ici_install (OPC_NIL);
	
	if (enable_log) {
		printf (" [Node %s] t= %f -> GTS MAC frame payload (MSDU) (size = %d bits) was generated and sent to MAC layer. \n\t - Next GTS MAC frame payload will be generated at t = %f.\n\n", node_name, op_sim_time(), msdu_size, abs_next_intarr_time);
	}
		
	/* Stack tracing exit point */
	FOUT;

}

/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_interrupt_process
 *
 * Description:	processes START_GTS_TRAFFIC remote interrupt
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_gts_interrupt_process(){

	double intarr_time;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_interrupt_process);

	/* call the interrupt processing for each interrupt */
	switch (op_intrpt_type()) {
		case OPC_INTRPT_REMOTE: 
		{
			switch (op_intrpt_code()) {
				case START_GTS_TRAFFIC:
				{
					/* schedule the interrupt for starting of the MSDU generation */
					intarr_time = oms_dist_outcome (msdu_interarrival_dist_ptr);
					
					/* make sure that interarrival time is not negative. In that case it will be set to 0. */
					if (intarr_time < 0)
						intarr_time = 0.0;
			
					op_intrpt_schedule_self (op_sim_time()+intarr_time , GENERATE);	
					break;
				};
				
				default:
				{
				};
			}		
			break;
		};
	
		default:
		{
		};
	}
	
	/* Stack tracing exit point */
	FOUT;

}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wpan_gts_traffic_source (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wpan_gts_traffic_source_init (int * init_block_ptr);
	void _op_wpan_gts_traffic_source_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wpan_gts_traffic_source_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wpan_gts_traffic_source_alloc (VosT_Obtype, int);
	void _op_wpan_gts_traffic_source_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wpan_gts_traffic_source (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_gts_traffic_source ());

		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */


		FSM_ENTER ("wpan_gts_traffic_source")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (0, "idle", state0_enter_exec, "wpan_gts_traffic_source [idle enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_gts_traffic_source [idle enter execs]", state0_enter_exec)
				{
				/* call the interrupt processing for each interrupt */
				wpan_gts_interrupt_process ();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"wpan_gts_traffic_source")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "idle", "wpan_gts_traffic_source [idle exit execs]")


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_gts_traffic_source [idle trans conditions]", state0_trans_conds)
			FSM_INIT_COND (MSDU_GENERATE)
			FSM_TEST_COND (STOP)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state0_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ;, "MSDU_GENERATE", "", "idle", "generate", "tr_11", "wpan_gts_traffic_source [idle -> generate : MSDU_GENERATE / ]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "STOP", "", "idle", "stop", "tr_14", "wpan_gts_traffic_source [idle -> stop : STOP / ]")
				FSM_CASE_TRANSIT (2, 0, state0_enter_exec, ;, "default", "", "idle", "idle", "tr_6", "wpan_gts_traffic_source [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (generate) enter executives **/
			FSM_STATE_ENTER_FORCED (1, "generate", state1_enter_exec, "wpan_gts_traffic_source [generate enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_gts_traffic_source [generate enter execs]", state1_enter_exec)
				{
				/* Generate and send a GTS MSDU (MAC frame payload) */
				wpan_gts_traffic_generate ();
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** state (generate) exit executives **/
			FSM_STATE_EXIT_FORCED (1, "generate", "wpan_gts_traffic_source [generate exit execs]")


			/** state (generate) transition processing **/
			FSM_TRANSIT_FORCE (0, state0_enter_exec, ;, "default", "", "generate", "idle", "tr_13", "wpan_gts_traffic_source [generate -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (stop) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "stop", state2_enter_exec, "wpan_gts_traffic_source [stop enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_gts_traffic_source [stop enter execs]", state2_enter_exec)
				{
				/* When we enter into the "stop" state, it is the time for us to	*/
				/* stop generating traffic. We simply cancel the generation of the	*/
				/* next MSDU (MAC frame payload) and go into a silent mode by not   */
				/* scheduling anything	else.										*/
				
				if (op_ev_valid (next_msdu_evh) == OPC_TRUE)
					op_ev_cancel (next_msdu_evh);
				
				if (enable_log) {						
					printf (" [Node %s] t=%f\n   -> STOP to generate the GTS traffic with given parameters. \n\n", node_name, op_sim_time());
				}
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"wpan_gts_traffic_source")


			/** state (stop) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "stop", "wpan_gts_traffic_source [stop exit execs]")


			/** state (stop) transition processing **/
			FSM_TRANSIT_FORCE (2, state2_enter_exec, ;, "default", "", "stop", "stop", "tr_16", "wpan_gts_traffic_source [stop -> stop : default / ]")
				/*---------------------------------------------------------*/



			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (3, "init", "wpan_gts_traffic_source [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_gts_traffic_source [init enter execs]", state3_enter_exec)
				{
				/* Initialization */
				wpan_gts_source_init ();
				
				/* Register the statistics that will be maintained by this model.	*/
				bits_sent_hndl     			= op_stat_reg ("GTS Traffic Source.Generated Traffic (bits/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				msdus_sent_hndl     		= op_stat_reg ("GTS Traffic Source.Generated Traffic (MSDUs/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				msdu_size_hndl      		= op_stat_reg ("GTS Traffic Source.MSDU Size (bits)",               OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				msdu_interarrival_time_hndl = op_stat_reg ("GTS Traffic Source.MSDU Interarrival Time (secs)",  OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				msdus_hndl  				= op_stat_reg ("GTS Traffic Source.Number of MSDUs", 			 		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				bits_sent_hndlG     = op_stat_reg ("GTS Traffic Source.Generated Traffic (bits/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				msdus_hndlG  		= op_stat_reg ("GTS Traffic Source.Number of MSDUs", 					OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "init", "wpan_gts_traffic_source [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (0, state0_enter_exec, ;, "default", "", "init", "idle", "tr_4", "wpan_gts_traffic_source [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (3,"wpan_gts_traffic_source")
		}
	}




void
_op_wpan_gts_traffic_source_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wpan_gts_traffic_source_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wpan_gts_traffic_source_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wpan_gts_traffic_source_svar function. */
#undef msdu_interarrival_dist_ptr
#undef msdu_size_dist_ptr
#undef msdu_interarrival_dist_str
#undef msdu_size_dist_str
#undef acknowledgement
#undef node_name
#undef next_msdu_evh
#undef parent_id
#undef enable_log
#undef bits_sent_hndl
#undef bits_sent_hndlG
#undef msdus_sent_hndl
#undef msdu_size_hndl
#undef msdu_interarrival_time_hndl
#undef msdus_hndl
#undef msdus_hndlG

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wpan_gts_traffic_source_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wpan_gts_traffic_source_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_gts_traffic_source)",
		sizeof (wpan_gts_traffic_source_state));
	*init_block_ptr = 6;

	FRET (obtype)
	}

VosT_Address
_op_wpan_gts_traffic_source_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_gts_traffic_source_state * ptr;
	FIN_MT (_op_wpan_gts_traffic_source_alloc (obtype))

	ptr = (wpan_gts_traffic_source_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wpan_gts_traffic_source [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_gts_traffic_source_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_gts_traffic_source_state		*prs_ptr;

	FIN_MT (_op_wpan_gts_traffic_source_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_gts_traffic_source_state *)gen_ptr;

	if (strcmp ("msdu_interarrival_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdu_interarrival_dist_ptr);
		FOUT
		}
	if (strcmp ("msdu_size_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdu_size_dist_ptr);
		FOUT
		}
	if (strcmp ("msdu_interarrival_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->msdu_interarrival_dist_str);
		FOUT
		}
	if (strcmp ("msdu_size_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->msdu_size_dist_str);
		FOUT
		}
	if (strcmp ("acknowledgement" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->acknowledgement);
		FOUT
		}
	if (strcmp ("node_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->node_name);
		FOUT
		}
	if (strcmp ("next_msdu_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->next_msdu_evh);
		FOUT
		}
	if (strcmp ("parent_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->parent_id);
		FOUT
		}
	if (strcmp ("enable_log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->enable_log);
		FOUT
		}
	if (strcmp ("bits_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_hndl);
		FOUT
		}
	if (strcmp ("bits_sent_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_hndlG);
		FOUT
		}
	if (strcmp ("msdus_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdus_sent_hndl);
		FOUT
		}
	if (strcmp ("msdu_size_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdu_size_hndl);
		FOUT
		}
	if (strcmp ("msdu_interarrival_time_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdu_interarrival_time_hndl);
		FOUT
		}
	if (strcmp ("msdus_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdus_hndl);
		FOUT
		}
	if (strcmp ("msdus_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->msdus_hndlG);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

