/* Process model C form file: wpan_synchro_process.pr.c */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_synchro_process.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_synchro_process_pr_c [] = "MIL_3_Tfile_Hdr_ 150A 30A op_runsim_dev 7 4B067786 4B067786 1 nb-pju jurcikp 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files		*/
#include "headers\wpan_params.h"
#include "headers\wpan_math.h"
#include "headers\wpan_struct.h"


/* Node configuration constants		*/

/* Input and output streams		*/
#define STRM_FROM_SYNCHRO_TO_MAC     0

/* Interrupt types		*/


/* Constants			*/


/* State machine conditions */
#define IAM_PAN_COORDINATOR ((my_attributes.is_PANcoordinator == OPC_TRUE) && (start_beacon == OPC_TRUE))

/* Function prototypes */
static void wpan_synchro_init (void);
static void wpan_send_beacon_frame (void);


/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Boolean	                		start_beacon                                    ;	/* Is the Beacon_Order and Superframe_Order in the range [0,14]? */
	wpan_node_attributes	   		my_attributes                                   ;	/* the attributes of the node (MAC Address, PAN ID, ...) */
	wpan_mac_attributes	    		mac_attributes                                  ;	/* the Medium Access Attributes */
	} wpan_synchro_process_state;

#define start_beacon            		op_sv_ptr->start_beacon
#define my_attributes           		op_sv_ptr->my_attributes
#define mac_attributes          		op_sv_ptr->mac_attributes

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_synchro_process_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_synchro_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*********************************************************************************
 * If the node is PAN Coordinator then the node generates a first beacon frame and
 * sends it out for the synchronization of the other nodes in the WPAN.
**********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_sychro_init
 *
 * Description:	- initialize the process
 *				- check if the node is a PAN coordinator
 *              - read the beacon order (BO) and the superframe order (SO)
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_synchro_init() {

	Objid wpan_attributes_comp_id; 
	Objid wpan_attributes_id;  
	Objid gts_attributes_comp_id;
	Objid gts_attributes_id;
	char error_msg[120];
	
	/* Stack tracing enrty point */
	FIN(wpan_synchro_init);
	
	/* obtain self object ID of the surrounding processor or queue */
	my_attributes.objid = op_id_self ();
	
	/* obtain object ID of the parent object (node) */
	my_attributes.parent_id = op_topo_parent (my_attributes.objid);	
	
	/*get the GTS Traffic Source attribute ID*/
	my_attributes.gts_traffic_source = op_id_from_name (my_attributes.parent_id, OPC_OBJTYPE_PROC, "GTS Traffic Source");
	
	if (my_attributes.gts_traffic_source == OPC_NIL) {
		op_sim_end("CANNOT FIND THE GTS TRAFFIC SOURCE MODULE ID","CHECK IF THE NAME OF THE GTS TRAFFIC SOURCE MODULE IS [GTS Traffic Source]","","");
	}
	
	
	/* get the MAC address of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "MAC Address", &my_attributes.mac_address);
	
	/* MAC address is not specified - Auto Assigned */
	if (my_attributes.mac_address == -2) {
		my_attributes.mac_address = my_attributes.objid;
	}
	
	/* get the name of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "name", &my_attributes.name);
	
	/* get the MAC Address of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "MAC Address", &my_attributes.mac_address);
	
	/* check the validity of the MAC address */
	if (my_attributes.mac_address == -1) {
		sprintf(error_msg, "The MAC Address of node \"%s\" is not specified ", &my_attributes.name); 
		op_sim_end (error_msg, "Simulation Aborted"," ", " ");
	}
	
	/* get the value to check if this node is PAN Coordinator or not */
	op_ima_obj_attr_get (my_attributes.parent_id, "Device Mode", &my_attributes.Device_Mode);
	
	my_attributes.is_PANcoordinator = OPC_FALSE;
	if (strcmp(my_attributes.Device_Mode, "PAN Coordinator") == 0) {
		my_attributes.is_PANcoordinator = OPC_TRUE;	
	}
	
	/* get the WPAN settings for the PAN Coordinator*/
	if (my_attributes.is_PANcoordinator == OPC_TRUE) {
		op_ima_obj_attr_get (my_attributes.parent_id, "WPAN Setting", &wpan_attributes_id);
		wpan_attributes_comp_id = op_topo_child (wpan_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
		op_ima_obj_attr_get (wpan_attributes_comp_id, "Beacon Order", &my_attributes.beacon_order);
		op_ima_obj_attr_get (wpan_attributes_comp_id, "Superframe Order", &my_attributes.superframe_order);
		op_ima_obj_attr_get (wpan_attributes_comp_id, "PAN ID", &my_attributes.pan_id);
	}
	else { /* if the node is not a PAN coordinator, use these value as defaults. */
		my_attributes.beacon_order = 15;
		my_attributes.superframe_order = 15;
		my_attributes.pan_id = -1;
	}	
	
	
	if ((my_attributes.superframe_order > my_attributes.beacon_order) && my_attributes.is_PANcoordinator && (my_attributes.superframe_order != 15)) {
		sprintf(error_msg, "Node \"%s\" is PAN Coordinator and its Superframe_Order(%d) > Beacon_Order(%d) (0<=SO<=B0<=14) ", my_attributes.name, my_attributes.superframe_order, my_attributes.beacon_order); 
		op_sim_end (error_msg, "Simulation Aborted"," ", " ");
	}
	
	/* get GTS parameters */
	op_ima_obj_attr_get (my_attributes.parent_id, "GTS Setting", &gts_attributes_id);
	gts_attributes_comp_id = op_topo_child (gts_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
	if (my_attributes.is_PANcoordinator == OPC_TRUE) {		
		op_ima_obj_attr_get (gts_attributes_comp_id, "GTS Permit", &my_attributes.is_GTS_Permit);		
	} else {
		my_attributes.is_GTS_Permit = OPC_FALSE;
	}	
	
	
	start_beacon = OPC_FALSE;	/* non beacon-enabled mode */
	if (my_attributes.beacon_order < 15)
		start_beacon = OPC_TRUE;	/* send out first beacon = beacon-enabled mode	*/
	
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_send_beacon_frame
 *
 * Description:	Create a beacon frame and send it to the MAC Layer (wpan_mac) for
 *				start of synchronization (first beacon)
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_send_beacon_frame() {

	Packet * beacon_frame;
	int final_CAP_slot;
	int beacon_interval;	/* the beacon interval in symbol */
	int slot_duration;	/* the slot duration in symbol */
	int superframe_duration;	/*  the superframe duration in symbol */
	
	/* Stack tracing enrty point */
	FIN(wpan_send_beacon_frame);

	final_CAP_slot = 15; /* no CFP (GTS) */
	beacon_interval = aBaseSuperframeDuration * exponent(2, my_attributes.beacon_order);
	slot_duration = aBaseSlotDuration * exponent(2, my_attributes.superframe_order);
	superframe_duration = aBaseSuperframeDuration * exponent(2, my_attributes.superframe_order);
	
	printf (" \nNODE \"%s\" IS A PAN COORDINATOR WITH A SUPERFRAME STRUCTURE AS FOLLOWS \n", my_attributes.name);
	printf (" \t Beacon Order (BO)     : %d \n", my_attributes.beacon_order);
	printf (" \t Superframe Order (SO) : %d \n", my_attributes.superframe_order);
	printf (" \t Beacon Interval       : %d = %f sec\n", beacon_interval, Symbols2Sec(beacon_interval, WPAN_DATA_RATE));
	printf (" \t Superframe Duration   : %d = %f ms\n", superframe_duration, Symbols2ms(superframe_duration, WPAN_DATA_RATE));
	printf (" \t Slot Duration         : %d = %f ms\n", slot_duration, Symbols2ms(slot_duration, WPAN_DATA_RATE));
	printf (" \t Final CAP slot        : %d\n\n", final_CAP_slot);
	
	/* create a beacon frame */
	beacon_frame = op_pk_create_fmt ("wpan_beacon_MSDU_format");
	
	/* set the fields of the beacon frame */
	op_pk_nfd_set (beacon_frame, "Beacon Order", my_attributes.beacon_order);
	op_pk_nfd_set (beacon_frame, "Superframe Order", my_attributes.superframe_order);
	op_pk_nfd_set (beacon_frame, "PAN Coordinator", my_attributes.is_PANcoordinator);
	op_pk_nfd_set (beacon_frame, "Final CAP Slot", final_CAP_slot);
	op_pk_nfd_set (beacon_frame, "GTS Permit", my_attributes.is_GTS_Permit);
	 /* Battery Life Extension if not defined in this first beacon. By default, it is disabled. */
	
	op_pk_send(beacon_frame, STRM_FROM_SYNCHRO_TO_MAC);	
	
	
	/* Stack tracing exit point */
	FOUT;
}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wpan_synchro_process (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wpan_synchro_process_init (int * init_block_ptr);
	void _op_wpan_synchro_process_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wpan_synchro_process_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wpan_synchro_process_alloc (VosT_Obtype, int);
	void _op_wpan_synchro_process_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wpan_synchro_process (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_synchro_process ());

		{


		FSM_ENTER ("wpan_synchro_process")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "wpan_synchro_process [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_synchro_process [init enter execs]", state0_enter_exec)
				{
				/*Initialization */
				wpan_synchro_init();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "wpan_synchro_process [init exit execs]")


			/** state (init) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_synchro_process [init trans conditions]", state0_trans_conds)
			FSM_INIT_COND (IAM_PAN_COORDINATOR)
			FSM_TEST_COND (!IAM_PAN_COORDINATOR)
			FSM_TEST_LOGIC ("init")
			FSM_PROFILE_SECTION_OUT (state0_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ;, "IAM_PAN_COORDINATOR", "", "init", "first_beacon", "tr_6", "wpan_synchro_process [init -> first_beacon : IAM_PAN_COORDINATOR / ]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "!IAM_PAN_COORDINATOR", "", "init", "idle", "tr_16", "wpan_synchro_process [init -> idle : !IAM_PAN_COORDINATOR / ]")
				}
				/*---------------------------------------------------------*/



			/** state (first_beacon) enter executives **/
			FSM_STATE_ENTER_FORCED (1, "first_beacon", state1_enter_exec, "wpan_synchro_process [first_beacon enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_synchro_process [first_beacon enter execs]", state1_enter_exec)
				{
				/* if attribute Device Mode = PAN Coordinator -> send first beacon for synchronization */
				wpan_send_beacon_frame();
				
				
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** state (first_beacon) exit executives **/
			FSM_STATE_EXIT_FORCED (1, "first_beacon", "wpan_synchro_process [first_beacon exit execs]")


			/** state (first_beacon) transition processing **/
			FSM_TRANSIT_FORCE (2, state2_enter_exec, ;, "default", "", "first_beacon", "idle", "tr_17", "wpan_synchro_process [first_beacon -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "idle", state2_enter_exec, "wpan_synchro_process [idle enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_synchro_process [idle enter execs]", state2_enter_exec)
				{
				/* IDLE state */
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"wpan_synchro_process")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "idle", "wpan_synchro_process [idle exit execs]")


			/** state (idle) transition processing **/
			FSM_TRANSIT_FORCE (2, state2_enter_exec, ;, "default", "", "idle", "idle", "tr_18", "wpan_synchro_process [idle -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wpan_synchro_process")
		}
	}




void
_op_wpan_synchro_process_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wpan_synchro_process_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wpan_synchro_process_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wpan_synchro_process_svar function. */
#undef start_beacon
#undef my_attributes
#undef mac_attributes

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wpan_synchro_process_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wpan_synchro_process_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_synchro_process)",
		sizeof (wpan_synchro_process_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_wpan_synchro_process_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_synchro_process_state * ptr;
	FIN_MT (_op_wpan_synchro_process_alloc (obtype))

	ptr = (wpan_synchro_process_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wpan_synchro_process [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_synchro_process_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_synchro_process_state		*prs_ptr;

	FIN_MT (_op_wpan_synchro_process_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_synchro_process_state *)gen_ptr;

	if (strcmp ("start_beacon" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->start_beacon);
		FOUT
		}
	if (strcmp ("my_attributes" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_attributes);
		FOUT
		}
	if (strcmp ("mac_attributes" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mac_attributes);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

