/* Process model C++ form file: wpan_mac_process.pr.cpp */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_mac_process.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_mac_process_pr_cpp [] = "MIL_3_Tfile_Hdr_ 150A 30A modeler 7 4B067805 4B067805 1 nb-pju jurcikp 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                           ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files		*/
#include "headers\wpan_struct.h"
#include "headers\wpan_params.h"
#include "headers\wpan_math.h"
#include <math.h>
#include <prg_list_funcs.h>


/* Input and output streams		*/
#define STRM_FROM_RADIO_TO_MAC    0
#define STRM_FROM_MAC_TO_RADIO    0
#define STRM_FROM_SYNCHRO_TO_MAC  1
#define STRM_FROM_UNACK_TO_MAC    2
#define STRM_FROM_ACK_TO_MAC 	  3
#define STRM_FROM_GTS_TO_MAC	  4
#define STRM_FROM_MAC_TO_SINK     5


/* Statistics Input Index */
#define TX_BUSY_STAT 0
#define RX_BUSY_STAT 1
#define RX_COLLISION_STAT 2


/* Constants		*/
#define _Epsilon  0.000000000000
#define	INFINITE_TIME -1.0

#define INITIANLLY_EMPTY_GTS_BUFFER OPC_TRUE // OPC_FALSE = initally full GTS buffer, OPC_TRUE = initially empty GTS buffer

// subqueues
#define SUBQ_ZERO 0
#define SUBQ_GTS 1

#define TIME_SLOT_INDEX_MAX (aNumSuperframeSlots-1)

#define GTS_DIRECTION_TRANSMIT 0	// device->PANCoord
#define GTS_DIRECTION_RECEIVE 1	// PANCoord->device

// define the time spend in the CCA = 8 symbols
#define	WPAN_CCA_DETECTION_TIME_Symbols	8


/* GTS characteristics type */
#define GTS_DEALLOCATION 0
#define GTS_ALLOCATION 1


/* Interrupt types		*/
#define DEFAULT_CODE 0
#define BEACON_INTERVAL_CODE 1
#define TIME_SLOT_CODE 2
#define TRY_PACKET_TRANSMISSION_CODE 23
#define BACKOFF_EXPIRATION_CODE 17
#define START_OF_CAP_PERIOD_CODE 25

// the same value should be in the Battery Module for remote process
#define PACKET_TX_CODE 101
#define PACKET_RX_CODE 102
#define END_OF_SLEEP_PERIOD 103
#define END_OF_ACTIVE_PERIOD_CODE 104
#define END_OF_CAP_PERIOD_CODE 105

#define END_OF_CFP_PERIOD_CODE 6
#define CCA_START_CODE 7
#define CCA_EXPIRATION_CODE 8
#define RETURN_TO_BACKOFF_CODE 19
#define FAILURE_CODE 10
#define SUCCESS_CODE 11
#define START_TRANSMISSION_CODE 30
#define WAITING_ACK_END_CODE 36
#define ACK_SUCCESS_CODE 43
#define ACK_FAILURE_CODE 44 
#define ACK_SEND_CODE 47

// GTS
#define START_OF_GTS_USE 200
#define STOP_OF_GTS_USE 201
#define START_OF_GTS_PERIOD 210
#define END_OF_GTS_PERIOD 211
#define TRY_GTS_PACKET_TRANSMISSION_CODE 230

// remote GTS for GTS Traffic Source module - the same value in GTS Traffic Source module
#define START_GTS_TRAFFIC 220
#define STOP_GTS_TRAFFIC 221



/* State machine conditions 		*/
#define IAM_PAN_COORDINATOR (my_attributes.is_PANcoordinator == OPC_TRUE)

#define IAM_WAITING_ACK (mac_attributes.wait_ack==OPC_TRUE)

#define BACKOFF_EXPIRED (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == BACKOFF_EXPIRATION_CODE) 
#define	DEFAULT_INTRPT	(op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == DEFAULT_CODE) 

#define PACKET_READY_TO_SEND ((SF.CAP_ACTIVE==OPC_TRUE) && (SF.SLEEP==OPC_FALSE) &&\
                              !(op_subq_empty(SUBQ_ZERO)) && \
                              (op_stat_local_read(TX_BUSY_STAT)==0.0) && \
                              (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == TRY_PACKET_TRANSMISSION_CODE))


#define CHANNEL_BUSY (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == RETURN_TO_BACKOFF_CODE)


#define CAP_IS_ACTIVE ((SF.CAP_ACTIVE==OPC_TRUE) && (SF.SLEEP==OPC_FALSE) && (SF.CFP_ACTIVE==OPC_FALSE))

#define TX_FAILURE (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == FAILURE_CODE)
#define TX_SUCCESS (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == SUCCESS_CODE)
#define RX_ACK_SUCCESS (op_intrpt_type () == OPC_INTRPT_SELF && op_intrpt_code () == ACK_SUCCESS_CODE)
#define CCA_END (TX_FAILURE || (TX_SUCCESS && !IAM_WAITING_ACK)|| RX_ACK_SUCCESS )

#define GTS_START ((SF.CFP_ACTIVE==OPC_TRUE) && (SF.CAP_ACTIVE==OPC_FALSE) &&\
					(SF.SLEEP==OPC_FALSE) && (GTS.GTS_ACTIVE==OPC_TRUE))
/*
#define GTS_STOP ((SF.CFP_ACTIVE==OPC_TRUE) && (SF.CAP_ACTIVE==OPC_FALSE) &&\
					(SF.SLEEP==OPC_FALSE) && (GTS.GTS_ACTIVE==OPC_FALSE))
*/

#define GTS_STOP_IDLE	((SF.CFP_ACTIVE==OPC_TRUE) && (SF.CAP_ACTIVE==OPC_FALSE) &&\
						(SF.SLEEP==OPC_FALSE) && (GTS.GTS_ACTIVE==OPC_FALSE) && (SF.CCA_DEFERRED==OPC_FALSE))
#define GTS_STOP_CCA	((SF.CFP_ACTIVE==OPC_TRUE) && (SF.CAP_ACTIVE==OPC_FALSE) &&\
						(SF.SLEEP==OPC_FALSE) && (GTS.GTS_ACTIVE==OPC_FALSE) && (SF.CCA_DEFERRED==OPC_TRUE))

/* Structures		*/
/* statistic vectors */
typedef struct {
	Stathandle failure;
	Stathandle success;
	Stathandle ch_busy_cca1;
	Stathandle ch_busy_cca2;
	Stathandle ch_idle_cca1;
	Stathandle ch_idle_cca2;
	Stathandle deferred_cca;
	Stathandle dropped_ack_packets;
	Stathandle dropped_packets;
	Stathandle retransmission_attempts;
	Stathandle success_ack_packets;
	Stathandle backoff_delay;
	Stathandle mac_delay;
	Stathandle backoff_units;
	Stathandle mac_delay_ack_frame;
	Stathandle mac_delay_unack_frame;
	Stathandle sent_pkt;
	Stathandle deferred_cca_backoff;
} wpan_statistic_vector; 

typedef struct {
	Stathandle failure;
	Stathandle success;
	Stathandle ch_busy_cca1;
	Stathandle ch_busy_cca2;
	Stathandle ch_idle_cca1;
	Stathandle ch_idle_cca2;
	Stathandle deferred_cca;
	Stathandle dropped_ack_packets;
	Stathandle dropped_packets;
	Stathandle retransmission_attempts;
	Stathandle success_ack_packets;
	Stathandle backoff_delay;
	Stathandle mac_delay;
	Stathandle backoff_units;
	Stathandle mac_delay_ack_frame;
	Stathandle mac_delay_unack_frame;
	Stathandle sent_pkt;
} wpan_global_statistic_vector; 

typedef struct {
	Stathandle sent_frames;	// number of sent MAC frames
	Stathandle sent_framesG;
	Stathandle frame_delay;	// MAC frame delay (time between the MSDU generation and frame trasmission)
	Stathandle wasted_bandwidth_pc; // [%]
	Stathandle throughput_pc;	// [%]
	Stathandle buffer_saturation_pc;	// [%]
} wpan_gts_statistic_vector;

typedef struct {
	double band_wast_sum; // [%] sum of the wasted bandwidth (IFS, waiting, ACK) during the using of GTS
	double frame_delay_max;	// MAC frame delay (time between the MSDU generation and frame trasmission)
	double frame_delay_min;
	double frame_delay_sum;
	double sent_frames;	// total number of MAC frames sent during the using of GTS
	double sent_bits;	// total number of data bits sent during the using of GTS
	double generated_frames;	// total number of generated MAC frames
	double generated_bits;	// total number of generated data bits
	double dropped_frames;	// number of MAC frames which is dropped because of full buffer
	double dropped_bits;	// number of data bits which is dropped because of full buffer
	double gts_periods_count;	// number of GTS periods during the using of GTS
} wpan_gts_statictics;

/* GTS structures */
/* structure carried in the GTS request command frame */
typedef struct {
	int length;	// length of the GTS [# superframe slots]
	int direction; // direction of the transmission (device->PANCoord (transmit)=0, PANCoord->device(receive)=1)
	int characteristics_type;	// deallocation=0, allocation=1
} wpan_gts_characteristics;

/* structure carried in the beacon frame - GTS_list_field */
typedef struct {
	int device_short_address;
	int start_slot;
	int length;
} wpan_gts_descriptor;


/* Function prototypes.				*/
static void wpan_mac_init (void);
static void wpan_log_file_init (void);
static void fprint_mac_attributes (void);
static void print_mac_attributes (void);
static void wpan_parse_incoming_frame (void);
static void wpan_encapsualte_beacon_frame (Packet* beacon_frame);
static void wpan_encapsulate_and_enqueue_command_frame (Packet* cmd_frame, Boolean ack, int dest_address);
static void wpan_encapsulate_and_enqueue_data_frame (Packet* data_frame, Boolean ack, int dest_address);
static void wpan_extract_beacon_frame (Packet* mac_frame);
static void wpan_extract_command_frame (Packet* mac_frame);
static void wpan_extract_ack_frame (Packet* mac_frame);
static void wpan_extract_data_frame (Packet* mac_frame);
static void wpan_schedule_next_beacon (void);
static void wpan_send_beacon_frame (void);
static void wpan_send_ack_frame (int sequence_number);
static void wpan_mac_interrupt_process (void);

// backoff functions
static void   wpan_backoff_init (void);
static void   wpan_backoff_update (void);
static void   wpan_backoff_delay_set (void);
static int    wpan_backoff_period_index_get (void);
static double wpan_backoff_period_boundary_get (void);
static int 	  wpan_backoff_period_index_get_ (double Time);
static double wpan_backoff_period_boundary_get_ (double Time);

// cca functions
static Boolean  wpan_cca_defer (void);
static void 	wpan_cca_perform (int cca_index);
static void 	wpan_cca_expire (void);

static int wpan_current_time_slot_get (void);
static int wpan_ifs_symbol_get (Packet* frame_to_send);
static int wpan_update_sequence_number (void);

// battery update functions
static void wpan_battery_update_tx (double pksize);
static void wpan_battery_update_rx (double pksize, int frame_type);

// GTS functions
static void wpan_gts_scheduling (void);
static void wpan_gts_allocation_request (void);
static void wpan_gts_deallocation_request (void);
static void wpan_gts_reallocation_request (void);
static void wpan_gts_request_extract (Packet* mac_frame);
static void wpan_encapsulate_and_enqueue_gts_frame (Packet* rcv_frame);
static Boolean wpan_gts_check_time (Packet* frame_to_send);
static void wpan_gts_slot_init (void);

// utility functions
static void* gts_nested_list_mem_copy_create (void *from_ptr, unsigned int size);
static void gts_nested_list_mem_free (void *from_ptr);
static void queue_status (void);
static void cap_is_not_active (void);


/* Global variables	*/
//extern double PPDU_sent_bits;	// Total number of bits (PPDU) dispatched to the network [kbits]


/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
class wpan_mac_process_state
	{
	private:
		/* Internal state tracking for FSM */
		FSM_SYS_STATE

	public:
		wpan_mac_process_state (void);

		/* Destructor contains Termination Block */
		~wpan_mac_process_state (void);

		/* State Variables */
		wpan_node_attributes	   		my_attributes                                   ;	/* the attributes of the node (MAC Address, PAN ID, ...) */
		wpan_csma_attributes	   		csma                                            ;	/* the attributes of csma/ca (backoff, BE, ...) */
		wpan_gts_attributes	    		GTS                                             ;	/* the attributes of the GTS mechanism */
		wpan_superframe_strucuture			SF                                              ;	/* the parameters of the superframe structure */
		wpan_mac_attributes	    		mac_attributes                                  ;	/* the Medium Access Attributes */
		FILE *	                 		log                                             ;	/* a log file to store the operations for each node */
		Boolean	                		enable_log                                      ;	/* if enabled, all the operation will be saved in a log file */
		wpan_statistic_vector	  		statistic_vector                                ;	/* the statistic vector */
		wpan_global_statistic_vector			statistic_global_vector                         ;
		int	                    		ack_sequence_number                             ;	/* sequence number of the received packet */
		double	                 		backoff_start_time                              ;	/* the time when the packet enters the backoff */
		int	                    		Final_CAP_slot_next                             ;	/* value of SF.Final_CAP_slot variable valid in the next superframe */
		Boolean	                		is_waiting_GTS_confirm                          ;	/* waiting for the confimation about the allocated GTS slots */
		                        		                                                	/* from beacon frame after GTS request command was sent out  */
		Boolean	                		is_deallocation_req_sent                        ;	/* TRUE if the deallocation request was sent out to PANCoordinator */
		int	                    		wait_GTS_confirm_count                          ;
		Boolean	                		is_GTS_tx_time_active                           ;	/* TRUE if the GTS period is active and a packet is transmitted: */
		                        		                                                	/* |PACKET|+|IFS|                                                */
		int	                    		sent_gts_bits                                   ;	/* number of bits sent during one GTS period */
		wpan_gts_statistic_vector			gts_statistic_vector                            ;	/* GTS statistic vector */
		wpan_gts_statictics	    		gts_statistics                                  ;	/* GTS statistic scalars */
		double	                 		gts_pkt_delay                                   ;	/* delay of the GTS packet - from the creation time to the transmission time */
		int	                    		gts_queue_capacity                              ;	/* the capacity of the GTS buffer [bits] */
		Boolean	                		start_GTS_transmission                          ;
		Boolean	                		waiting_for_first_beacon                        ;	/* GTS request was issued before reception of first beacon               */
		                        		                                                	/* (usually when GTS.Start Time = 0) - wait for first beacon and         */
		                        		                                                	/* then check if PAN coordinator accepts GTS request (GTS permit = TRUE) */

		/* FSM code */
		void wpan_mac_process (OP_SIM_CONTEXT_ARG_OPT);
		/* Diagnostic Block */
		void _op_wpan_mac_process_diag (OP_SIM_CONTEXT_ARG_OPT);

#if defined (VOSD_NEW_BAD_ALLOC)
		void * operator new (size_t) throw (VOSD_BAD_ALLOC);
#else
		void * operator new (size_t);
#endif
		void operator delete (void *);

		/* Memory management */
		static VosT_Obtype obtype;
	};

VosT_Obtype wpan_mac_process_state::obtype = (VosT_Obtype)OPC_NIL;

#define my_attributes           		op_sv_ptr->my_attributes
#define csma                    		op_sv_ptr->csma
#define GTS                     		op_sv_ptr->GTS
#define SF                      		op_sv_ptr->SF
#define mac_attributes          		op_sv_ptr->mac_attributes
#define log                     		op_sv_ptr->log
#define enable_log              		op_sv_ptr->enable_log
#define statistic_vector        		op_sv_ptr->statistic_vector
#define statistic_global_vector 		op_sv_ptr->statistic_global_vector
#define ack_sequence_number     		op_sv_ptr->ack_sequence_number
#define backoff_start_time      		op_sv_ptr->backoff_start_time
#define Final_CAP_slot_next     		op_sv_ptr->Final_CAP_slot_next
#define is_waiting_GTS_confirm  		op_sv_ptr->is_waiting_GTS_confirm
#define is_deallocation_req_sent		op_sv_ptr->is_deallocation_req_sent
#define wait_GTS_confirm_count  		op_sv_ptr->wait_GTS_confirm_count
#define is_GTS_tx_time_active   		op_sv_ptr->is_GTS_tx_time_active
#define sent_gts_bits           		op_sv_ptr->sent_gts_bits
#define gts_statistic_vector    		op_sv_ptr->gts_statistic_vector
#define gts_statistics          		op_sv_ptr->gts_statistics
#define gts_pkt_delay           		op_sv_ptr->gts_pkt_delay
#define gts_queue_capacity      		op_sv_ptr->gts_queue_capacity
#define start_GTS_transmission  		op_sv_ptr->start_GTS_transmission
#define waiting_for_first_beacon		op_sv_ptr->waiting_for_first_beacon

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_mac_process_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_mac_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_mac_init
 *
 * Description:	- initialize the process
 *				- read the attributes and set the global variables
 *
 * No parameters
 *--------------------------------------------------------------------------------*/


static void wpan_mac_init() {

	Objid wpan_attributes_comp_id; 
	Objid wpan_attributes_id;  	
	Objid csma_attributes_comp_id;
	Objid csma_attributes_id;	
	Objid mac_attributes_comp_id;
	Objid mac_attributes_id;	
	Objid gts_attributes_comp_id;
	Objid gts_attributes_id;
	Objid traffic_source_id;	
	Objid queue_objid;	
	Objid subq_objid;	
	
	/* Stack tracing enrty point */
	FIN(wpan_mac_init);	
	
	/* obtain self object ID of the surrounding processor or queue */
	my_attributes.objid = op_id_self ();	
	
	/* obtain object ID of the parent object (node) */
	my_attributes.parent_id = op_topo_parent (my_attributes.objid);
	
	/* obtain object ID of the Traffic Source node */
	traffic_source_id = op_id_from_name(my_attributes.parent_id, OPC_OBJTYPE_PROC, "Traffic Source");
	
	/* obtain destination MAC address for data transmission  */
	op_ima_obj_attr_get (traffic_source_id, "Destination MAC Address", &my_attributes.traffic_destination_address);	
	
	/*get the battery attribute ID*/
	my_attributes.my_battery = op_id_from_name (my_attributes.parent_id, OPC_OBJTYPE_PROC, "Battery");

	if (my_attributes.my_battery == OPC_NIL) {
		op_sim_end("CANNOT FIND THE BATTERY ID","CHECK IF THE NAME OF THE BATTERY MODULE IS [Battery]","","");
	}
	
	/*get the GTS Traffic Source attribute ID*/
	my_attributes.gts_traffic_source = op_id_from_name (my_attributes.parent_id, OPC_OBJTYPE_PROC, "GTS Traffic Source");
	
	if (my_attributes.gts_traffic_source == OPC_NIL) {
		op_sim_end("CANNOT FIND THE GTS TRAFFIC SOURCE MODULE ID","CHECK IF THE NAME OF THE GTS TRAFFIC SOURCE MODULE IS [GTS Traffic Source]","","");
	}		
	
	/* get the MAC address of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "MAC Address", &my_attributes.mac_address);
	
	/* MAC address is not specified - Auto Assigned */
	if (my_attributes.mac_address == -2) {
		my_attributes.mac_address = my_attributes.objid;
	}
	
	/* get the name of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "name", &my_attributes.name);
	
	/* get the geographic position of the node */
	op_ima_obj_attr_get (my_attributes.parent_id, "x position", &my_attributes.x);
	op_ima_obj_attr_get (my_attributes.parent_id, "y position", &my_attributes.y);
	op_ima_obj_attr_get (my_attributes.parent_id, "altitude", &my_attributes.altitude);	
	
	/* get the value to check if this node is PAN coordinator or not */
	op_ima_obj_attr_get (my_attributes.parent_id, "Device Mode", &my_attributes.Device_Mode);
	
	my_attributes.is_PANcoordinator = OPC_FALSE;
	if (strcmp(my_attributes.Device_Mode, "PAN Coordinator")==0)
		my_attributes.is_PANcoordinator = OPC_TRUE;
		
	/* get GTS parameters */
	op_ima_obj_attr_get (my_attributes.parent_id, "GTS Setting", &gts_attributes_id);
	gts_attributes_comp_id = op_topo_child (gts_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
	if (IAM_PAN_COORDINATOR) {		
		op_ima_obj_attr_get (gts_attributes_comp_id, "GTS Permit", &my_attributes.is_GTS_Permit);
		GTS.start_time = -1.0;
		GTS.start_time = -1.0;
		GTS.length = 0;
		GTS.direction = 0;
		gts_queue_capacity = 0;		
	} else {
		my_attributes.is_GTS_Permit = OPC_FALSE;	
		op_ima_obj_attr_get (gts_attributes_comp_id, "Start Time", &GTS.start_time);
		op_ima_obj_attr_get (gts_attributes_comp_id, "Stop Time", &GTS.stop_time);
		op_ima_obj_attr_get (gts_attributes_comp_id, "Length", &GTS.length);
		op_ima_obj_attr_get (gts_attributes_comp_id, "Direction", &GTS.direction);	
		op_ima_obj_attr_get (gts_attributes_comp_id, "Buffer Capacity", &gts_queue_capacity);	/* obtain buffer size for storing the GTS data frames  */
	}
	
	GTS.retries_nbr = 0;
	
	/* get the subqueues object ID */
	op_ima_obj_attr_get (my_attributes.objid, "subqueue", &queue_objid);
	
	/* obtain object ID of the SUBQ_GTS subqueue */
	subq_objid = op_topo_child (queue_objid, OPC_OBJMTYPE_ALL, SUBQ_GTS);
	
	/* set the bit capacity of the appropriate subqueue */
	op_ima_obj_attr_set (subq_objid, "bit capacity", (double) gts_queue_capacity);
	
	/* get the WPAN settings for the PAN Coordinator*/
	if (IAM_PAN_COORDINATOR) {
		op_ima_obj_attr_get (my_attributes.parent_id, "WPAN Setting", &wpan_attributes_id);
		wpan_attributes_comp_id = op_topo_child (wpan_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
		op_ima_obj_attr_get (wpan_attributes_comp_id, "Beacon Order", &my_attributes.beacon_order);
		op_ima_obj_attr_get (wpan_attributes_comp_id, "Superframe Order", &my_attributes.superframe_order);
		op_ima_obj_attr_get (wpan_attributes_comp_id, "PAN ID", &my_attributes.pan_id);
		my_attributes.PANcoordinator_mac_address = my_attributes.mac_address;
	}
	else { /* if the node is not a PAN coordinator, use these value as defaults. */
		my_attributes.beacon_order = 15;
		my_attributes.superframe_order = 15;
		my_attributes.pan_id = -1;
		my_attributes.PANcoordinator_mac_address = -1;
	}
	
	/* memory allocation for GTS lists */
	if (my_attributes.is_GTS_Permit && IAM_PAN_COORDINATOR)
		my_attributes.GTS_list_PC = op_prg_list_create();	/* allocate an empty list */	

	/* inicialization of the GTS variables */
	is_waiting_GTS_confirm = OPC_FALSE;
	is_deallocation_req_sent = OPC_FALSE;
	wait_GTS_confirm_count = 0;
	
	SF.current_slot = 0;
	SF.Final_CAP_Slot = TIME_SLOT_INDEX_MAX; /* no CFP (GTSs) */
	SF.RESUME_BACKOFF_TIMER = OPC_FALSE;
	SF.backoff_timer= -1;
	SF.CCA_DEFERRED = OPC_FALSE;
	
	Final_CAP_slot_next = SF.Final_CAP_Slot;

	/* get the MAC settings */
	op_ima_obj_attr_get (my_attributes.objid, "MAC Attributes", &mac_attributes_id);
	mac_attributes_comp_id = op_topo_child (mac_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
	op_ima_obj_attr_get (mac_attributes_comp_id, "Batterie Life Extension", &mac_attributes.Battery_Life_Extension);
	mac_attributes.wait_ack = OPC_FALSE;
	mac_attributes.wait_ack_seq_num = 0;
	
	/* get the CSMA-CA settings */
	op_ima_obj_attr_get (my_attributes.objid, "CSMA-CA Parameters", &csma_attributes_id);
	csma_attributes_comp_id = op_topo_child (csma_attributes_id, OPC_OBJTYPE_GENERIC, 0);
	
	op_ima_obj_attr_get (csma_attributes_comp_id, "Maximum Backoff Number", &csma.MAX_CSMA_BACKOFF);
	op_ima_obj_attr_get (csma_attributes_comp_id, "Minimum Backoff Exponent", &csma.macMinBE);	
	
	/* CSMA initialization	*/
	csma.NB = 0;
	csma.CW = 2;
	csma.BE = csma.macMinBE;
	csma.retries_nbr = 0;	
	csma.CCA_CHANNEL_IDLE = OPC_TRUE;	
	if (mac_attributes.Battery_Life_Extension == OPC_TRUE)
		csma.BE = min_int(2, csma.macMinBE);
	
	
	if (INITIANLLY_EMPTY_GTS_BUFFER) {
		/* start the GTS transmission directly - initially empty buffer*/
		start_GTS_transmission = OPC_TRUE;
	} else {
		/* start the GTS transmission after the buffer will be full - initially full buffer */
		start_GTS_transmission = OPC_FALSE;	 
	}
	
	/* register the statistics */
	statistic_vector.failure = op_stat_reg ("CSMA.Transmission Failure", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.success = op_stat_reg ("CSMA.Transmission Success", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.ch_busy_cca1 = op_stat_reg ("CSMA.|CCA1| Busy Channel", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.ch_busy_cca2 = op_stat_reg ("CSMA.|CCA2| Busy Channel", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.ch_idle_cca1 = op_stat_reg ("CSMA.|CCA1| Idle Channel", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.ch_idle_cca2 = op_stat_reg ("CSMA.|CCA2| Idle Channel", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.deferred_cca = op_stat_reg ("CSMA.CCA Deference", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.dropped_ack_packets = op_stat_reg ("CSMA.Dropped Acknowledged Packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.dropped_packets = op_stat_reg ("CSMA.Dropped Packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.retransmission_attempts = op_stat_reg ("CSMA.Retransmission Attempts", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.success_ack_packets = op_stat_reg ("CSMA.Successfully Acknowledged Packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.backoff_delay = op_stat_reg ("CSMA.Backoff Delay (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.mac_delay = op_stat_reg ("CSMA.Medium Access Delay (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.backoff_units = op_stat_reg ("CSMA.Backoff Delay (Backoff Period Units)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.mac_delay_ack_frame = op_stat_reg ("CSMA.Medium Access Delay of Acknowledged Frames (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.mac_delay_unack_frame = op_stat_reg ("CSMA.Medium Access Delay of Unacknowledged Frames (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	statistic_vector.sent_pkt = op_stat_reg ("Network Output Load (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);	
	statistic_vector.deferred_cca_backoff = op_stat_reg ("CSMA.CCA and Backoff Deference", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	/* register the GLOBAL statistics */	
	statistic_global_vector.dropped_ack_packets = op_stat_reg ("CSMA.Dropped Acknowledged Packets", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.dropped_packets = op_stat_reg ("CSMA.Dropped Packets", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.mac_delay_ack_frame = op_stat_reg ("CSMA.Medium Access Delay of Acknowledged Frames (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.mac_delay_unack_frame = op_stat_reg ("CSMA.Medium Access Delay of Unacknowledged Frames (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.mac_delay = op_stat_reg ("CSMA.Medium Access Delay (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.success_ack_packets = op_stat_reg ("CSMA.Successfully Acknowledged Packets", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	statistic_global_vector.sent_pkt = op_stat_reg ("Network Output Load (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	/* GTS statistics */
	gts_statistic_vector.sent_frames = op_stat_reg ("GTS.Network Output Load (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	gts_statistic_vector.sent_framesG = op_stat_reg ("GTS.Network Output Load (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL); 
	gts_statistic_vector.frame_delay = op_stat_reg ("GTS.Packets Medium Access Delay (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	gts_statistic_vector.wasted_bandwidth_pc = op_stat_reg ("GTS.Wasted bandwith due to IFS (%)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	gts_statistic_vector.buffer_saturation_pc = op_stat_reg ("GTS.Buffer saturation (%)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	gts_statistic_vector.throughput_pc = op_stat_reg ("GTS.Throughput (%)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	
	gts_statistics.band_wast_sum = 0;
	gts_statistics.dropped_frames = 0;	//  number of droped GTS frames	
	gts_statistics.dropped_bits = 0;	// MPDU bits	
	gts_statistics.frame_delay_sum = 0;
	gts_statistics.frame_delay_max = 0;
	gts_statistics.frame_delay_min = LONG_MAX;
	gts_statistics.sent_frames = 0;	// number of dispatched GTS frames
	gts_statistics.sent_bits = 0;	// PPDU bits
	gts_statistics.gts_periods_count = 0;
	gts_statistics.generated_frames = 0;	// number of generated GTS frames
	gts_statistics.generated_bits = 0;	// MPDU bits
	

	op_ima_obj_attr_get (my_attributes.parent_id, "Enable Logging", &enable_log);

	print_mac_attributes ();
	
	wpan_log_file_init ();	
		
	fprint_mac_attributes();
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	 wpan_log_file_init
 *
 * Description:	log file init
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void  wpan_log_file_init() {
 
	char directory_path_name[120];
	char log_name[132];
	
	/* Stack tracing enrty point */
	FIN(wpan_log_file_init);

	op_ima_obj_attr_get (my_attributes.parent_id, "Log File Directory", directory_path_name);
	
	/* verification if the directory_path_name is a valid directory */
	if (prg_path_name_is_dir (directory_path_name) == PrgC_Path_Name_Is_Not_Dir) {
		char msg[128];		
		sprintf (msg, " \"%s\" is not valid directory name. The output will not be logged.\n", directory_path_name); 
		/* Display an appropriate warning.	*/
		op_prg_odb_print_major ("Warning from wpan_mac process: ", msg, OPC_NIL);			
		enable_log = OPC_FALSE;
	}	
	
	if (enable_log) {
		sprintf (log_name, "%s%s.ak", directory_path_name, my_attributes.name); 
		printf ("Log file name: %s \n\n", log_name);
		log = fopen(log_name,"w");
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------*
 * Function:	fprint_attributes
 *
 * Description:	print all the mac attributes of the current node in a file
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void fprint_mac_attributes() {

	/* Stack tracing enrty point */
	FIN(fprint_mac_attributes);

	if (enable_log) {	
		fprintf (log, "|-----------------------------------------------------------------------------|\n");
		fprintf (log, "| NODE NAME          : %s \n",my_attributes.name);
		fprintf (log, "| DEVICE MODE        : %s \n",my_attributes.Device_Mode);
		fprintf (log, "| MAC ADDRESS        : %d \n\n",my_attributes.mac_address);
	
		fprintf (log, "| GEOGRAPHIC POSITION \n");
		fprintf (log, "|   POSITION x       : %f \n",my_attributes.x);
		fprintf (log, "|   POSITION y       : %f \n",my_attributes.y);
		fprintf (log, "|   ALTITUTE z       : %f \n\n",my_attributes.altitude);
	
		if (my_attributes.is_PANcoordinator) {
			fprintf (log, "| SUPERFRAME PARAMETERS \n");
			fprintf (log, "|   BEACON ORDER             : %d \n",my_attributes.beacon_order);
			fprintf (log, "|   SUPERFRAME ORDER         : %d \n",my_attributes.superframe_order);
			fprintf (log, "|   PAN ID                   : %d \n",my_attributes.pan_id);
			fprintf (log, "|   PAN COORDINATOR ADDRESS  : %d \n\n",my_attributes.PANcoordinator_mac_address);		
			fprintf (log, "| GTS Permit : %s \n\n", boolean2string(my_attributes.is_GTS_Permit));
		} else {
			fprintf (log, "| GTS PARAMETERS \n");
			fprintf (log, "|   START TIME : %f \n", GTS.start_time);
			fprintf (log, "|   STOP TIME  : %f \n", GTS.stop_time);
			fprintf (log, "|   DIRECTION  : %d \n", GTS.direction);
			fprintf (log, "|   LENGTH     : %d slots\n", GTS.length);
			if (INITIANLLY_EMPTY_GTS_BUFFER) 
				fprintf (log, "|   (initially empty buffer)\n\n");
			else
				fprintf (log, "|   (initially full buffer)\n\n");
		}
	
		fprintf (log, "| CSMA PARAMETERS \n");	
		fprintf (log, "|   MAXIMUM BACKOFF NUMBER    : %d \n",csma.MAX_CSMA_BACKOFF);
		fprintf (log, "|   MAXIMUM BACKOFF EXPONENT  : %d \n",csma.macMinBE);
		fprintf (log, "|   BATTERY LIFE EXTENSION    : %s \n",boolean2string(mac_attributes.Battery_Life_Extension));
		fprintf (log, "|-----------------------------------------------------------------------------|\n\n");	
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	print_mac_attributes
 *
 * Description:	print all the MACc attributes of the current node to the standart output device
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void print_mac_attributes() {

	/* Stack tracing enrty point */
	FIN(print_mac_attributes);

	if (enable_log) {
		printf( "|-----------------------------------------------------------------------------|\n");
		printf( "| NODE NAME          : %s \n",my_attributes.name);
		printf( "| DEVICE MODE        : %s \n",my_attributes.Device_Mode);
		printf( "| MAC ADDRESS        : %d \n\n",my_attributes.mac_address);
	
		printf ( "| GEOGRAPHIC POSITION \n");
		printf ( "|   POSITION x      : %f \n",my_attributes.x);
		printf ( "|   POSITION y      : %f \n",my_attributes.y);
		printf ( "|   ALTITUTE z      : %f \n\n",my_attributes.altitude);
	
		if (my_attributes.is_PANcoordinator) {
			printf ( "| SUPERFRAME PARAMETERS \n");
			printf ( "|   BEACON ORDER              : %d \n",my_attributes.beacon_order);
			printf ( "|   SUPERFRAME ORDER          : %d \n",my_attributes.superframe_order);
			printf ( "|   PAN ID                    : %d \n",my_attributes.pan_id);
			printf ( "|   PAN COORDINATOR ADDRESS   : %d \n\n",my_attributes.PANcoordinator_mac_address);		
			printf ( "| GTS Permit : %s \n\n", boolean2string(my_attributes.is_GTS_Permit));		
		} else {
			printf ( "| GTS PARAMETERS \n");
			printf ( "|   START TIME : %f \n", GTS.start_time);
			printf ( "|   STOP TIME  : %f \n", GTS.stop_time);
			printf ( "|   DIRECTION  : %d \n", GTS.direction);
			printf ( "|   LENGTH     : %d slots\n", GTS.length);
			if (INITIANLLY_EMPTY_GTS_BUFFER) 
				printf ( "|   (initially empty buffer)\n\n");
			else
				printf ( "|   (initially full buffer)\n\n");
		}
	
		printf ( "| CSMA PARAMETERS \n");	
		printf ( "|   MAXIMUM BACKOFF NUMBER     : %d \n",csma.MAX_CSMA_BACKOFF);
		printf ( "|   MAXIMUM BACKOFF EXPONENT   : %d \n",csma.macMinBE);
		printf ( "|   BATTERY LIFE EXTENSION     : %s \n", boolean2string(mac_attributes.Battery_Life_Extension));
		printf ( "|-----------------------------------------------------------------------------|\n\n");	
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_parse_incoming_frame
 *
 * Description:	parse the incoming packet and make the adequate processing
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_parse_incoming_frame() {

	Packet* frame_MPDU;
	Packet* rcv_frame;
	int Stream_ID;
	int frame_type_fd;
	int source_address;
	int dest_address;
	double packet_size;

	
	/* Stack tracing enrty point */
	FIN(wpan_parse_incoming_frame);

	/* get the packet from the input stream	*/
	Stream_ID = op_intrpt_strm();
	rcv_frame = op_pk_get (Stream_ID);	
	
	/* check from what input stream the packet is received and do the right processing	*/		
	switch (Stream_ID) {
		case STRM_FROM_SYNCHRO_TO_MAC: /* A FIRST BEACON PAYLOAD (MSDU) FROM THE SYNCHRO MODULE (only for PANCoordinator) */
		{
			wpan_encapsualte_beacon_frame (rcv_frame);
			break;
		};
	
		case STRM_FROM_UNACK_TO_MAC: /* INCOMMING UNACKNOWLEDGED PAYLOAD (MSDU) FROM THE TRAFFIC SOURCE */
		{			
			wpan_encapsulate_and_enqueue_data_frame (rcv_frame, OPC_FALSE, my_attributes.traffic_destination_address);			
			break;
		};
	
		case STRM_FROM_ACK_TO_MAC: /* INCOMMING ACKNOWLEDGED PAYLOAD (MSDU) FROM THE TRAFFIC SOURCE */
		{
			wpan_encapsulate_and_enqueue_data_frame (rcv_frame, OPC_TRUE, my_attributes.traffic_destination_address);			
			break;
		};
	
		case STRM_FROM_GTS_TO_MAC:	/* INCOMMING GTS PAYLOAD (MSDU) FROM THE GTS TRAFFIC SOURCE */
		{			
			wpan_encapsulate_and_enqueue_gts_frame (rcv_frame);
			break;
		};
	
		case STRM_FROM_RADIO_TO_MAC: /*A PHY FRAME (PPDU) FROM THE RADIO RECIEVER*/
		{			
		
			/* get MAC frame (MPDU=PSDU) from received PHY frame (PPDU)*/
			op_pk_nfd_get_pkt (rcv_frame, "PSDU", &frame_MPDU);

			/*acquire "Frame Type" field*/
			op_pk_nfd_get (frame_MPDU, "Frame Type", &frame_type_fd);
			
			/*update the battery*/
			packet_size = (double) op_pk_total_size_get(rcv_frame);
			wpan_battery_update_rx (packet_size, frame_type_fd);
			
			op_pk_destroy (rcv_frame);
						
			/*Check "Frame Type" field*/
			if (frame_type_fd == ACK_FRAME_TYPE) {	/* acknowledgment frame */			
				if (enable_log) {
					fprintf (log,"t=%f  -> ACK Frame Reception - WAITING for ACK? = %s\n\n",op_sim_time(), boolean2string(mac_attributes.wait_ack));
					printf (" [Node %s] t=%f  -> ACK Frame Reception - WAITING for ACK? = %s\n\n",my_attributes.name,op_sim_time(), boolean2string(mac_attributes.wait_ack));
				}
				wpan_extract_ack_frame (frame_MPDU);			
			}
			else if (frame_type_fd == BEACON_FRAME_TYPE) { /* beacon frame */
				op_pk_nfd_get (frame_MPDU, "Source Address", &source_address);
				
				if (enable_log) {
					fprintf (log,"t=%f  -> Beacon Frame Reception From @%d \n\n", op_sim_time(), source_address);
					printf (" [Node %s] t=%f  -> Beacon Frame Reception From @%d \n\n", my_attributes.name, op_sim_time(), source_address);
				}
						
				wpan_extract_beacon_frame (frame_MPDU);
			}
			else {   /*if it is not an ACK Frame*/			
				op_pk_nfd_get (frame_MPDU, "Source Address", &source_address);
				op_pk_nfd_get (frame_MPDU, "Destination Address", &dest_address);
			
				/*Check if the frame is loop*/
				if (source_address == my_attributes.mac_address) {
					if (enable_log) {
						fprintf(log,"t=%f  -> Loop: DISCARD FRAME \n\n",op_sim_time());
						printf (" [Node %s] t=%f  -> Loop: DISCARD FRAME \n\n",my_attributes.name, op_sim_time());
					}
					op_pk_destroy (frame_MPDU);
				} 
				else if ((dest_address != my_attributes.mac_address) && (dest_address!= BROADCAST_ADDRESS)) {
					if (enable_log) {
						fprintf (log,"t=%f  -> Frame Reception From @%d \n\n",op_sim_time(), source_address);
						printf (" [Node %s] t=%f  -> Frame Reception From @%d \n\n",my_attributes.name, op_sim_time(), source_address);

						fprintf (log,"t=%f  -> Wrong Destination Address (my_address: %d <-> dest_address: %d) : DISCARD FRAME \n\n",op_sim_time(), my_attributes.mac_address, dest_address);
						printf (" [Node %s] t=%f  -> Wrong Destination Address (my_address: %d <-> dest_address: %d) : DISCARD FRAME \n\n",my_attributes.name, op_sim_time(), my_attributes.mac_address, dest_address);
					}
					op_pk_destroy (frame_MPDU);
				}
				else {	// dest_address = my_attributes.mac_address or dest_address = BROADCAST_ADDRESS 
					switch(frame_type_fd) {						
						case DATA_FRAME_TYPE: 	/* For a data frame */
							if (enable_log) {
								fprintf (log,"t=%f  !!!!!!!!! Data Frame Reception From @%d !!!!!!!!! \n\n", op_sim_time(), source_address);
								printf (" [Node %s] t=%f  !!!!!!!!! Data Frame Reception From @%d !!!!!!!!! \n\n", my_attributes.name, op_sim_time(), source_address);
							}
							wpan_extract_data_frame (frame_MPDU);						
							break;
						case COMMAND_FRAME_TYPE:	/* For a Command frame */
						 	if (enable_log) {
								fprintf (log,"t=%f  !!!!!!!!! Command Frame Reception From @%d !!!!!!!!! \n\n", op_sim_time(), source_address);
								printf (" [Node %s] t=%f  !!!!!!!!! Command Frame Reception From @%d !!!!!!!!! \n\n", my_attributes.name, op_sim_time(), source_address);
							}
							wpan_extract_command_frame (frame_MPDU);
							break;
						default:	/*OTHER FRAME TYPES*/
							break;					
					}
				}
			}
			break;
		};
	
		default :
		{
		};
	}

	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_encapsualte_beacon_frame
 *
 * Description:	encapsulate the first beacon payload (MSDU) received from the sychro module 
 *              into a MAC frame (MPDU) and PHY frame (PPDU), and sends it to the network and schedule the next beacon frame 
 *
 *  Input :  beacon_MSDU - the beacon payload (MSDU) for encapsulation
 *--------------------------------------------------------------------------------*/

static void wpan_encapsualte_beacon_frame(Packet* beacon_MSDU){

	Packet* beacon_MPDU;	
	Packet* beacon_PPDU;
	double beacon_frame_creation_time;
	int seq_num;
		
	/* Stack tracing enrty point */
	FIN(wpan_encapsualte_beacon_frame);		
				
	/* create a MAC frame (MPDU) that encapsulates the beacon payload (MSDU) */
	beacon_MPDU = op_pk_create_fmt ("wpan_beacon_MPDU_format");
		
	// Generate the sequence number for the packet
	seq_num = wpan_update_sequence_number ();
	op_pk_nfd_set (beacon_MPDU, "Frame Type", BEACON_FRAME_TYPE);
	op_pk_nfd_set (beacon_MPDU, "Sequence Number", seq_num); 
	op_pk_nfd_set (beacon_MPDU, "Source PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (beacon_MPDU, "Source Address", my_attributes.mac_address);
	op_pk_nfd_set_pkt (beacon_MPDU, "MSDU", beacon_MSDU); // wrap beacon payload (MSDU) in MAC Frame (MPDU)
	op_pk_nfd_set (beacon_MPDU, "Ack Request", 0);

	//op_pk_print(beacon_MPDU); //print information about packet
		
	beacon_frame_creation_time = op_pk_creation_time_get(beacon_MSDU);
		
	// update the superframe parameters			
	SF.SD = aBaseSuperframeDuration * exponent(2,my_attributes.superframe_order);
	SF.BI = aBaseSuperframeDuration * exponent(2,my_attributes.beacon_order);
	SF.slot_duration = aBaseSlotDuration * exponent(2,my_attributes.superframe_order); // [symbols]
	SF.sleep_period = SF.BI - SF.SD;
	SF.BI_Boundary = beacon_frame_creation_time;
		
	if (enable_log) {
		fprintf(log,"t=%f  -> Beacon Frame transmission. \n\n", op_sim_time());
		printf(" [Node %s] t=%f  -> Beacon Frame transmission. \n\n", my_attributes.name, op_sim_time());
	}
		
	op_intrpt_schedule_self (SF.BI_Boundary+Bits2Sec(op_pk_total_size_get(beacon_MPDU), WPAN_DATA_RATE), START_OF_CAP_PERIOD_CODE);
	wpan_schedule_next_beacon ();
	
	/* create PHY frame (PPDU) that encapsulates beacon MAC frame (MPDU) */
	beacon_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
	
	/* wrap beacon MAC frame (MPDU) in PHY frame (PPDU) */
	op_pk_nfd_set_pkt (beacon_PPDU, "PSDU", beacon_MPDU);
	op_pk_nfd_set (beacon_PPDU, "Frame Length", ((double) op_pk_total_size_get(beacon_MPDU))/8); //[bytes]	
	
	wpan_battery_update_tx ((double) op_pk_total_size_get(beacon_PPDU));
	op_pk_send (beacon_PPDU, STRM_FROM_MAC_TO_RADIO);
	
	/* Stack tracing exit point */
	FOUT;	
}

 
/*--------------------------------------------------------------------------------
 * Function:	wpan_extract_beacon_frame
 *
 * Description:	extract the beacon frame from the MAC frame received from the network
 *              and schedule the next beacon frame
 *
 * Input :  mac_frame - the received MAC frame
 *--------------------------------------------------------------------------------*/

static void wpan_extract_beacon_frame(Packet* mac_frame){

	Packet* beacon_frame;
	PrgT_List* gts_list;
	wpan_gts_descriptor* gts_descriptor_ptr;
	Boolean is_it_from_PAN_Coord;
	double beacon_frame_creation_time;	
	int gts_directions_mask;
	int gts_descriptor_count;
	int gts_length;
	int i;
	
	/* Stack tracing enrty point */
	FIN(wpan_extract_beacon_frame);
		
	op_pk_nfd_get_pkt (mac_frame, "MSDU", &beacon_frame);		
		
	// if I'm a End Device, I get the information and sychronize myself
	if (!my_attributes.is_PANcoordinator) {
		op_pk_nfd_get (beacon_frame, "PAN Coordinator", &is_it_from_PAN_Coord);	
		
		if (is_it_from_PAN_Coord) {
			op_pk_nfd_get (mac_frame, "Source Address", &my_attributes.PANcoordinator_mac_address);
			op_pk_nfd_get (mac_frame, "Source PAN Identifier", &my_attributes.pan_id);			
			op_pk_nfd_get (beacon_frame, "Beacon Order", &my_attributes.beacon_order);
			op_pk_nfd_get (beacon_frame, "Superframe Order", &my_attributes.superframe_order);
			op_pk_nfd_get (beacon_frame, "Final CAP Slot", &SF.Final_CAP_Slot);
			op_pk_nfd_get (beacon_frame, "Battery Life Ext", &mac_attributes.Battery_Life_Extension);
			
			// update with actual PAN Coordinator address
			if (my_attributes.traffic_destination_address == PAN_COORDINATOR_ADDRESS)
				my_attributes.traffic_destination_address = my_attributes.PANcoordinator_mac_address;
			
			beacon_frame_creation_time = op_pk_creation_time_get (beacon_frame);
			
			if (waiting_for_first_beacon) {
				op_intrpt_schedule_self (op_sim_time(), START_OF_GTS_USE);
			}
			
			/* update the superframe parameters	*/		 
			SF.SD = aBaseSuperframeDuration * exponent(2, my_attributes.superframe_order);
			SF.BI = aBaseSuperframeDuration * exponent(2, my_attributes.beacon_order);
			SF.slot_duration = aBaseSlotDuration * exponent(2, my_attributes.superframe_order);
			SF.sleep_period = SF.BI - SF.SD;
			SF.BI_Boundary = beacon_frame_creation_time;
			
			
			/* GTS fields */
			op_pk_nfd_get (beacon_frame, "GTS Descriptor Count", &gts_descriptor_count);
			op_pk_nfd_get (beacon_frame, "GTS Permit", &my_attributes.is_GTS_Permit);
			
			/* find appropriate GTS_descriptor in the received GTS_list */
			if (gts_descriptor_count > 0) {			
				op_pk_nfd_get (beacon_frame, "GTS Directions", &gts_directions_mask);
				
				/* obtain the GTS list */
				op_pk_nfd_access (beacon_frame, "GTS List", &gts_list);
		
				for (i=0; i<op_prg_list_size (gts_list); i++) {					
					if ((gts_descriptor_ptr = (wpan_gts_descriptor *) op_prg_list_access (gts_list, i)) != OPC_NIL) {
						if (gts_descriptor_ptr->device_short_address == my_attributes.mac_address) { /* this GTS_descriptor is for me */
							GTS.start_slot = gts_descriptor_ptr->start_slot;	/* allocated GTS start slot */
							gts_length = gts_descriptor_ptr->length;	/* allocated GTS length */
							
							if (GTS.start_slot == 0) {
								if (is_waiting_GTS_confirm) {	/* GTS allocation was not successful */
									op_intrpt_disable (OPC_INTRPT_SELF, STOP_OF_GTS_USE, OPC_FALSE);	/* disable already scheduled GTS deallocation */									 
									
									if (enable_log) {
										fprintf (log, "t=%f  -> GTS allocation was not successful - GTS request was rejected by PANCoordinator. \n", op_sim_time());
										fprintf (log, "\t + PANCoordinator has not enough resources - the maximum available length for the GTS is %d slot(s). \n\n", gts_length);
										printf (" [Node %s] t=%f  -> GTS allocation was not successful - GTS request was rejected by PANCoordinator. \n", my_attributes.name, op_sim_time());
										printf ("\t + PANCoordinator has not enough resources - the maximum available length for the GTS is %d slot(s). \n\n", gts_length);
									}
								} 
							} else { /* (GTS.start_slot != 0) - GTS allocation was successful */								
								if ((GTS.direction == GTS_DIRECTION_TRANSMIT) && is_waiting_GTS_confirm) {
									/* start generate GTS Traffic */
									op_intrpt_schedule_remote (op_sim_time(), START_GTS_TRAFFIC, my_attributes.gts_traffic_source);
									
									if (enable_log) {
										fprintf (log, "t=%f  -> START to geneterate the GTS traffic with given parameters. \n\n", op_sim_time());
										printf (" [Node %s] t=%f  -> START to geneterate the GTS traffic with given parameters. \n\n", my_attributes.name, op_sim_time());
									}
								}								
							}
							
							/* I have already received beacon with GTS allocation response */
							is_waiting_GTS_confirm = OPC_FALSE; 	
							wait_GTS_confirm_count = 0;
						} 
					}
				}
			} 
			
			/* deallocation request was sent to PAN Coordinator - stop using the GTS */
			if (is_deallocation_req_sent)	{								
				GTS.start_slot = 0;	
				is_deallocation_req_sent = OPC_FALSE;
				op_stat_write (gts_statistic_vector.wasted_bandwidth_pc, 0.0); 
				op_stat_write (gts_statistic_vector.throughput_pc, 0.0);
			}	
			
			if (is_waiting_GTS_confirm) {
				if (wait_GTS_confirm_count == aGTSDescPersistenceTime) {
					is_waiting_GTS_confirm = OPC_FALSE;
					wait_GTS_confirm_count = 0;
					
					if (enable_log) {
						fprintf (log, "t=%f  -> !!!! GTS reqeuest failed - I have not received response from PANCoordinator. \n\n", op_sim_time());
						printf (" [Node %s] t=%f  -> !!!! GTS reqeuest failed - I have not received response from PANCoordinator. \n\n", my_attributes.name, op_sim_time());
					}					
				} else {
					wait_GTS_confirm_count = wait_GTS_confirm_count + 1;
				}			
			}
			
			if (enable_log) {
				printf (" [Node %s] t=%f  -> Beacon Frame Reception - synchronization. \n", my_attributes.name, op_sim_time());
				printf ("   -> BEACON ORDER (BO)     : %d \n", my_attributes.beacon_order);
				printf ("   -> SUPERFRAME ORDER (SO) : %d \n", my_attributes.superframe_order);
				printf ("   -> PAN ID                : %d \n", my_attributes.pan_id);
				printf ("   -> PAN COORDINATOR MAC ADDRESS  : %d \n", my_attributes.PANcoordinator_mac_address);
				printf ("   -> BEACON INTERVAL BOUNDARY     : %f Sec \n", SF.BI_Boundary);
				printf ("   -> SUPERFRAME DURATION          : %d Symbols = %f Sec \n", SF.SD, Symbols2Sec(SF.SD, WPAN_DATA_RATE));
				printf ("   -> BEACON INTERVAL              : %d Symbols = %f Sec\n", SF.BI, Symbols2Sec(SF.BI, WPAN_DATA_RATE));
				printf ("   -> TIME SLOT DURATION           : %d Symbols = %f Sec \n", SF.slot_duration, Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE));
				printf ("   -> FINAL CAP SLOT (0-15)        : %d \n", SF.Final_CAP_Slot);
				printf ("   -> BATT LIFE EXTENSION          : %s \n\n", boolean2string(mac_attributes.Battery_Life_Extension));	
				printf ("   -> GTS PERMIT by PANCoordinator : %s \n", boolean2string(my_attributes.is_GTS_Permit));
				if (GTS.start_slot > 0) {
					printf ("   -> ALLOCATED GTS START SLOT     : %d \n", GTS.start_slot);
					printf ("   -> ALLOCATED LENGTH OF THE GTS  : %d slots = %f sec \n", GTS.length, Symbols2Sec(GTS.length*SF.slot_duration, WPAN_DATA_RATE));
				} else {
					printf ("   -> NONE ALLOCATED GTS.\n");
				}
				printf ("\n");
			
				fprintf (log,"t=%f  -> Beacon Frame Reception - synchronization. \n",op_sim_time());
				fprintf (log,"   -> BEACON ORDER (BO)     : %d \n", my_attributes.beacon_order);
				fprintf (log,"   -> SUPERFRAME ORDER (SO) : %d \n", my_attributes.superframe_order);
				fprintf (log,"   -> PAN ID                : %d \n", my_attributes.pan_id);
				fprintf (log,"   -> PAN COORDINATOR MAC ADDRESS  : %d \n", my_attributes.PANcoordinator_mac_address);
				fprintf (log,"   -> BEACON INTERVAL BOUNDARY     : %f Sec \n", SF.BI_Boundary);
				fprintf (log,"   -> SUPERFRAME DURATION          : %d Symbols = %f Sec \n", SF.SD, Symbols2Sec(SF.SD, WPAN_DATA_RATE));
				fprintf (log,"   -> BEACON INTERVAL              : %d Symbols = %f Sec\n", SF.BI, Symbols2Sec(SF.BI, WPAN_DATA_RATE));
				fprintf (log,"   -> TIME SLOT DURATION           : %d Symbols = %f Sec \n", SF.slot_duration, Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE));
				fprintf (log,"   -> FINAL CAP SLOT (0-15)        : %d \n", SF.Final_CAP_Slot);
				fprintf (log,"   -> BATT LIFE EXTENSION          : %s \n\n", boolean2string(mac_attributes.Battery_Life_Extension));
				fprintf (log,"   -> GTS PERMIT by PANCoordinator : %s \n", boolean2string(my_attributes.is_GTS_Permit));
				if (GTS.start_slot > 0) {
					fprintf (log, "   -> ALLOCATED GTS START SLOT     : %d \n", GTS.start_slot);
					fprintf (log, "   -> ALLOCATED LENGTH OF THE GTS  : %d slots = %f sec \n", GTS.length, Symbols2Sec(GTS.length*SF.slot_duration, WPAN_DATA_RATE));
				} else {
					fprintf (log, "   -> NONE ALLOCATED GTS.\n");
				}
				fprintf (log, "\n");
			}
			
			/* schdedule the GTS data period - allocated GTS slot(s) in the End Device node*/
			if (GTS.start_slot > 0) {				
				op_intrpt_schedule_self (SF.BI_Boundary+Symbols2Sec(((GTS.start_slot)*SF.slot_duration), WPAN_DATA_RATE), START_OF_GTS_PERIOD);
				op_intrpt_schedule_self (SF.BI_Boundary+Symbols2Sec(((GTS.start_slot+GTS.length)*SF.slot_duration), WPAN_DATA_RATE), END_OF_GTS_PERIOD);
							
				if (enable_log) {
					fprintf (log, "t=%f  -> Schedule the GTS data period from %f sec to %f sec. \n\n", op_sim_time(), SF.BI_Boundary+Symbols2Sec(((GTS.start_slot)*SF.slot_duration), WPAN_DATA_RATE), SF.BI_Boundary+Symbols2Sec(((GTS.start_slot+GTS.length)*SF.slot_duration), WPAN_DATA_RATE));
					printf (" [Node %s] t=%f  -> Schedule the GTS data period from %f sec to %f sec. \n\n", my_attributes.name, op_sim_time(), SF.BI_Boundary+Symbols2Sec(((GTS.start_slot)*SF.slot_duration), WPAN_DATA_RATE), SF.BI_Boundary+Symbols2Sec(((GTS.start_slot+GTS.length)*SF.slot_duration), WPAN_DATA_RATE));
				}			
			}
			
			op_intrpt_schedule_self (op_sim_time(), DEFAULT_CODE);
			op_intrpt_schedule_self (op_sim_time(), START_OF_CAP_PERIOD_CODE);
	
			wpan_schedule_next_beacon();
			
		} else { /* is_it_from_PAN_Coord == OPC_FALSE */
			if (enable_log) {
				fprintf(log,"t=%f  -> Beacon Frame Reception  - but not from PAN Coordinator. \n",op_sim_time());	
				printf(" [Node %s] t=%f  -> Beacon Frame Reception - but not from PAN Coordinator. \n", my_attributes.name, op_sim_time());
			}
		}
	} 
	
	op_pk_destroy (beacon_frame);
	op_pk_destroy (mac_frame);
	
	/* Stack tracing exit point */
	FOUT;	
}


/*------------------------------------------------------------------------------
 * Function:	wpan_schedule_next_beacon
 *
 * Description:	generates the self interupt for the next beacon transmission
 *              and a self interrupts to indicate the end of the CAP and end of sleep period
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_schedule_next_beacon() {	

	/* Stack tracing enrty point */
	FIN(wpan_schedule_next_beacon);
	
	//printf("Sim Tim = %f -  [Node %s] : Next Beacon at time = %f    Next Time Slot = %f\n",op_sim_time(), my_attributes.name, SF.BI_Boundary+Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI_Boundary+Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE));
	//op_intrpt_priority_set (OPC_INTRPT_SELF, END_OF_CAP_PERIOD_CODE, -2);
	
	op_intrpt_schedule_self (SF.BI_Boundary+Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE), END_OF_CAP_PERIOD_CODE);
	
	//op_intrpt_priority_set (OPC_INTRPT_SELF, BEACON_INTERVAL_CODE, -2);
	
	op_intrpt_schedule_self (SF.BI_Boundary+Symbols2Sec(SF.BI, WPAN_DATA_RATE), BEACON_INTERVAL_CODE);
	
	op_intrpt_schedule_remote (SF.BI_Boundary+Symbols2Sec(SF.BI, WPAN_DATA_RATE), END_OF_SLEEP_PERIOD, my_attributes.my_battery);

	if (enable_log) {
		fprintf (log,"t=%f  -> Schedule Next Beacon at %f - End of CAP : %f\n\n", op_sim_time(), SF.BI_Boundary+Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI_Boundary+Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE));
		printf (" [Node %s] t=%f  -> Schedule Next Beacon at %f - End of CAP : %f\n\n", my_attributes.name, op_sim_time(), SF.BI_Boundary+Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI_Boundary+Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE));
	}
	
	/* Stack tracing exit point */
	FOUT;	
}


/*------------------------------------------------------------------------------
 * Function:	wpan_send_beacon_frame()
 *
 * Description:	the PAN coordinator send a beacon frame to the other nodes
 *              and schedule the transmission time of the next beacon
 *
 * No parameters
 *-----------------------------------------------------------------------------*/

static void wpan_send_beacon_frame() {

	Packet* beacon_MSDU;
	Packet* beacon_MPDU;	
	Packet* beacon_PPDU;
	PrgT_List* gts_list;	
	wpan_gts_list_PC_record* gts_list_PC_record_ptr;
	wpan_gts_descriptor* gts_descriptor_ptr;	
	double beacon_frame_creation_time;
	int gts_descriptor_count = 0;
	int gts_directions_mask = 0;
	int seq_num;
	int i;
	
	/* Stack tracing enrty point */
	FIN(wpan_send_beacon_frame);
	
	/* allocate an empty list */
	gts_list = op_prg_list_create ();
	
	/* create a beacon payload (MSDU) */
	beacon_MSDU = op_pk_create_fmt ("wpan_beacon_MSDU_format");
	
	/* set the fields of the beacon frame */
	op_pk_nfd_set (beacon_MSDU, "Beacon Order", my_attributes.beacon_order);
	op_pk_nfd_set (beacon_MSDU, "Superframe Order", my_attributes.superframe_order);
	op_pk_nfd_set (beacon_MSDU, "Final CAP Slot", SF.Final_CAP_Slot);
	op_pk_nfd_set (beacon_MSDU, "Battery Life Ext", mac_attributes.Battery_Life_Extension);
	op_pk_nfd_set (beacon_MSDU, "PAN Coordinator", my_attributes.is_PANcoordinator);
		
	/* set the appropriate GTS fields of the beacon frame */
	op_pk_nfd_set (beacon_MSDU, "GTS Permit", my_attributes.is_GTS_Permit);
	
	for (i=0; i<op_prg_list_size (my_attributes.GTS_list_PC); i++) {
		gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_list_access (my_attributes.GTS_list_PC, i);
		
		if (gts_list_PC_record_ptr->beacon_persistence_time > 0) {
			/* memory allocation */
			gts_descriptor_ptr	= (wpan_gts_descriptor *) op_prg_mem_alloc (sizeof (wpan_gts_descriptor));
			
			gts_descriptor_ptr->device_short_address = gts_list_PC_record_ptr->assoc_dev_address;
			gts_descriptor_ptr->start_slot = gts_list_PC_record_ptr->start_slot;
			gts_descriptor_ptr->length = gts_list_PC_record_ptr->length;
			
			/* insert the GTS descriptor onto the list tail */
			op_prg_list_insert (gts_list, gts_descriptor_ptr, OPC_LISTPOS_TAIL);
			
			gts_directions_mask = gts_directions_mask + (exponent(2, (6-gts_descriptor_count)) * gts_list_PC_record_ptr->direction);
			
			gts_list_PC_record_ptr->beacon_persistence_time = gts_list_PC_record_ptr->beacon_persistence_time - 1;	
			gts_descriptor_count = gts_descriptor_count + 1;			
		}		
	} 
	
	op_pk_nfd_set (beacon_MSDU, "GTS Descriptor Count", gts_descriptor_count);
	
	if (gts_descriptor_count > 0) {
		op_pk_nfd_set (beacon_MSDU, "GTS Directions", gts_directions_mask);		
		op_pk_nfd_set_ptr (beacon_MSDU, "GTS List", gts_list, gts_nested_list_mem_copy_create, gts_nested_list_mem_free, sizeof(wpan_gts_descriptor)*gts_descriptor_count);
		
		/* set the appropriate size of the GTS_Directions (8 bits) and GTS_List fields according the specification */
		op_pk_bulk_size_set (beacon_MSDU, (8 + gts_descriptor_count*24)); // the size of GTS_Descriptor = 24 bits
	}
	
	/* create MAC frame (MPDU) that encapsulates the beacon payload (MSDU) */
	beacon_MPDU = op_pk_create_fmt("wpan_beacon_MPDU_format");

	/* generate the sequence number for the packet to send */
	seq_num = wpan_update_sequence_number();		
		
	op_pk_nfd_set (beacon_MPDU, "Frame Type", BEACON_FRAME_TYPE);
	op_pk_nfd_set (beacon_MPDU, "Sequence Number", seq_num); 
	op_pk_nfd_set (beacon_MPDU, "Source PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (beacon_MPDU, "Source Address", my_attributes.mac_address);
	op_pk_nfd_set_pkt (beacon_MPDU, "MSDU", beacon_MSDU); // wrap beacon payload (MSDU) in MAC Frame (MPDU)
	op_pk_nfd_set (beacon_MPDU, "Ack Request", 0);
	
	beacon_frame_creation_time = op_pk_creation_time_get(beacon_MSDU);
		
	/* update the superframe parameters */ 			
	SF.SD = aBaseSuperframeDuration * exponent(2,my_attributes.superframe_order);
	SF.BI = aBaseSuperframeDuration * exponent(2,my_attributes.beacon_order);
	SF.slot_duration = aBaseSlotDuration * exponent(2,my_attributes.superframe_order);
	SF.sleep_period = SF.BI - SF.SD;
	SF.BI_Boundary = beacon_frame_creation_time;		
	
	if (enable_log) {
		fprintf (log, "t=%f  -> Beacon Frame Transmission. \n",op_sim_time());
		printf (" [Node %s] t=%f  -> Beacon Frame Transmission. \n",my_attributes.name,op_sim_time());
		
		fprintf (log, "\t %d GTS(s) is allocated in the actual superframe \n", op_prg_list_size (my_attributes.GTS_list_PC));
		printf ("\t  %d GTS(s) is allocated in the actual superframe \n", op_prg_list_size (my_attributes.GTS_list_PC));					
		
		for (i=0; i<op_prg_list_size (my_attributes.GTS_list_PC); i++) {
			gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_list_access (my_attributes.GTS_list_PC, i);
			
			fprintf (log, "\t For node: @%d \n", gts_list_PC_record_ptr->assoc_dev_address);
			fprintf (log, "\t  + Start slot: %d, Length: %d, Directions: %d, Beacon persistence time: %d \n", gts_list_PC_record_ptr->start_slot, gts_list_PC_record_ptr->length, gts_list_PC_record_ptr->direction, gts_list_PC_record_ptr->beacon_persistence_time);
			
			printf ("\t For node: @%d \n", gts_list_PC_record_ptr->assoc_dev_address);
			printf ("\t  + Start slot: %d, Length: %d, Directions: %d, Beacon persistence time: %d \n", gts_list_PC_record_ptr->start_slot, gts_list_PC_record_ptr->length, gts_list_PC_record_ptr->direction, gts_list_PC_record_ptr->beacon_persistence_time);
		}
		
		fprintf (log, "\n");
		printf ("\n");
	}
	
	/* update GTS_list_PC */
	wpan_gts_reallocation_request ();
		
	op_intrpt_schedule_self (SF.BI_Boundary+Bits2Sec(op_pk_total_size_get(beacon_MPDU), WPAN_DATA_RATE)+_Epsilon, START_OF_CAP_PERIOD_CODE);
	wpan_schedule_next_beacon ();	
	
	/* create PHY frame (PPDU) that encapsulates beacon MAC frame (MPDU) */
	beacon_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
	
	/* wrap beacon MAC frame (MPDU) in PHY frame (PPDU) */
	op_pk_nfd_set_pkt (beacon_PPDU, "PSDU", beacon_MPDU); 
	op_pk_nfd_set (beacon_PPDU, "Frame Length", ((double) op_pk_total_size_get(beacon_MPDU))/8); //[bytes]
	
	wpan_battery_update_tx ((double)op_pk_total_size_get(beacon_PPDU));
	op_pk_send (beacon_PPDU, STRM_FROM_MAC_TO_RADIO);	
	
	/* Stack tracing exit point */
	FOUT;	
}


/*-----------------------------------------------------------------------------
 * Function:	wpan_extract_data_frame
 *
 * Description:	extract the data frame from the MAC frame received from the network
 *              
 * Input :  frame_MPDU - the received MAC frame
 *-----------------------------------------------------------------------------*/

static void wpan_extract_data_frame(Packet* frame_MPDU) {

	int Ack_Request;
	int seq_num;
	
	/* Stack tracing enrty point */
	FIN(wpan_extract_data_frame);
	
	/* check if any ACK is requested */	
	op_pk_nfd_get (frame_MPDU, "Ack Request", &Ack_Request);	
	if (Ack_Request) {		
		op_pk_nfd_get (frame_MPDU, "Sequence Number", &seq_num);		
		wpan_send_ack_frame (seq_num);			
	}else { /* ACK is not requested */
		/* send to higher layer for statistics */
		op_pk_send (frame_MPDU, STRM_FROM_MAC_TO_SINK);	
	}
	
	/* Stack tracing exit point */
	FOUT;	
}

/*-----------------------------------------------------------------------------
 * Function:	wpan_extract_command_frame
 *
 * Description:	extract the command frame from the MAC frame received from the network
 *              
 * Input :  frame_MPDU - the received MAC frame 
 *-----------------------------------------------------------------------------*/

static void wpan_extract_command_frame(Packet* frame_MPDU) {
	
	Packet* command_frame;
	Packet* frame_MPDU_copy;
	int Ack_Request;
	int seq_num;
	int command_frm_id;
	
	/* Stack tracing enrty point */
	FIN(wpan_extract_command_frame);
		
	/* check if any ACK is requested */	
	op_pk_nfd_get (frame_MPDU, "Ack Request", &Ack_Request);	
	if (Ack_Request) {		
		op_pk_nfd_get (frame_MPDU, "Sequence Number", &seq_num);
		wpan_send_ack_frame (seq_num);		
	}else { /* ACK is not requested */
		/* send to higher layer for statistics */
		op_pk_send (frame_MPDU, STRM_FROM_MAC_TO_SINK);	
	}
	
	
	frame_MPDU_copy = op_pk_copy (frame_MPDU);
	op_pk_nfd_get_pkt (frame_MPDU_copy, "MSDU", &command_frame);
	op_pk_nfd_get (command_frame, "Command Frame Identifier", &command_frm_id);
	
	/* check the command type */
	switch(command_frm_id) {
		case GTS_REQ:	/* GTS request command - allocation & deallocation of GTS */
		{
			if (IAM_PAN_COORDINATOR) {
				wpan_gts_request_extract (frame_MPDU);
			} else {				
				/* display an appropriate warning */
				op_prg_odb_print_major ("Warning - the GTS Request: \n I have received GTS request command, but I AM NOT PAN COORDINATOR!!.\n\n", OPC_NIL);				
				fprintf(log,"t=%f  -> Warning - I have received GTS request, but I AM NOT PAN COORDINATOR!!.\n\n", op_sim_time());
			}
			break;
		};
	
		default:
		{
		};		
	}	
	
	op_pk_destroy (frame_MPDU_copy);
	op_pk_destroy (command_frame);

	/* Stack tracing exit point */
	FOUT;	
}


/*-----------------------------------------------------------------------------
 * Function:	wpan_send_ack_frame
 *
 * Description:	send back to the sender ACK frame
 *
 * Input :  seq_num - expected sequence number
 *-----------------------------------------------------------------------------*/
static void wpan_send_ack_frame(int seq_num) {

	double ack_tx_time;
	
	/* Stack tracing enrty point */
	FIN(wpan_send_ack_frame);
	
	ack_sequence_number = seq_num;
				
	if (enable_log) {
		fprintf(log,"t=%f  -> ACK Frame Requested - Schedule to Send ACK Frame [SEQ = %d] at %f\n\n", op_sim_time(), seq_num, wpan_backoff_period_boundary_get_(op_sim_time()+ Symbols2Sec(aTurnaroundTime_Symbol, WPAN_DATA_RATE)));
		printf(" [Node %s] t=%f  -> ACK Frame Requested - Schedule to Send ACK Frame [SEQ = %d] at %f \n\n", my_attributes.name, op_sim_time(), seq_num, wpan_backoff_period_boundary_get_(op_sim_time()+ Symbols2Sec(aTurnaroundTime_Symbol, WPAN_DATA_RATE)));
	}
	
	if (GTS.GTS_ACTIVE)
		ack_tx_time = op_sim_time()+ Symbols2Sec(aTurnaroundTime_Symbol, WPAN_DATA_RATE); /* not use backoff period boundary in the GTS */
	else
		ack_tx_time = wpan_backoff_period_boundary_get_(op_sim_time()+ Symbols2Sec(aTurnaroundTime_Symbol, WPAN_DATA_RATE));	/* send ACK on the backoff period boundary */

	/* send back the ACK*/
	op_intrpt_schedule_self (ack_tx_time , ACK_SEND_CODE);
	
	/* Stack tracing exit point */
	FOUT;	
}


/*-----------------------------------------------------------------------------
 * Function:	wpan_extract_ack_frame
 *
 * Description:	check if the sequence number of the received ACK frame is the
 *				expected one.
 *
 * Input :  akc_frame - the MAC ACK frame
 *-----------------------------------------------------------------------------*/

static void wpan_extract_ack_frame(Packet* ack_frame) {

	int seq_num;
	Packet* mac_frame_dup;
	
	/* Stack tracing enrty point */
	FIN(wpan_extract_ack_frame);
	
	op_pk_nfd_get (ack_frame, "Sequence Number", &seq_num);
	
	/* if I'm waiting for an ACK */
	if (mac_attributes.wait_ack == OPC_TRUE) {
		if (mac_attributes.wait_ack_seq_num == seq_num) { /* yes, I have received my ACK */
			mac_attributes.wait_ack = OPC_FALSE;
		
			/* disable the invocation of only the next interrupt of WAITING_ACK_END_CODE */
			op_intrpt_disable (OPC_INTRPT_SELF, WAITING_ACK_END_CODE, OPC_TRUE);
		
			if (GTS.GTS_ACTIVE) {
				/* remove the duplicated mac_frame from GTS subqueue */
				mac_frame_dup = op_subq_pk_remove (SUBQ_GTS, OPC_QPOS_HEAD);	
				
				op_stat_write (gts_statistic_vector.frame_delay, gts_pkt_delay);

				gts_statistics.frame_delay_sum = gts_statistics.frame_delay_sum + gts_pkt_delay;
				gts_statistics.frame_delay_max = max_double (gts_statistics.frame_delay_max, gts_pkt_delay);
				gts_statistics.frame_delay_min = min_double (gts_statistics.frame_delay_min, gts_pkt_delay);	
			} else {			
				/* remove the duplicated mac_frame from subqueue */
				mac_frame_dup = op_subq_pk_remove (SUBQ_ZERO, OPC_QPOS_HEAD);
			}
		
			/* send the mac_frame to higher layer for statistics */
			op_pk_send (mac_frame_dup, STRM_FROM_MAC_TO_SINK);
			
			if (enable_log) {
				fprintf(log,"t=%f  -> ACK Frame Reception [Requested SEQ = %d], \n   -> Duplicate packet removed at the head of subqueue \n -> ACK waiting timer disabled. \n\n", op_sim_time(), seq_num);
				printf(" [Node %s] t=%f  -> ACK Frame Reception [Requested SEQ = %d]\n   -> Duplicate packet removed at the head of subqueue  \n   -> ACK waiting timer disabled. \n\n", my_attributes.name, op_sim_time(), seq_num);
			}

			/* Try to send another packet */
			op_intrpt_schedule_self (op_sim_time(), ACK_SUCCESS_CODE);
			
		} else	{	/* No, This is not my ACK, I'm Still Waiting */
			if (enable_log) {
				fprintf(log,"t=%f  -> WRONG ACK Frame Reception [RCV = %d], Still Waiting ACK [RQST = %d] \n\n", op_sim_time(), seq_num , mac_attributes.wait_ack_seq_num );
				printf(" [Node %s] t=%f  -> WRONG ACK Frame Reception [RCV = %d], Still Waiting ACK [RQST = %d] \n\n", my_attributes.name, op_sim_time(), seq_num , mac_attributes.wait_ack_seq_num );
			}
		}
	} else {/* if (mac_attributes.wait_ack == OPC_FALSE) */ 
		if (enable_log) {
			fprintf (log,"t=%f  -> I'm not Waiting ACK Frame - ACK Frame Destroyed. \n\n", op_sim_time());	
			printf (" [Node %s] t=%f  -> I'm not Waiting ACK Frame - ACK Frame Destroyed. \n\n", my_attributes.name, op_sim_time());
		}
	}
	
	/* destroy the ACK packet */
	op_pk_destroy (ack_frame);
	
	/* Stack tracing exit point */
	FOUT;	
}


/*--------------------------------------------------------------------------------
 * Function: wpan_encapsulate_and_enqueue_data_frame
 *
 * Description:	encapsulates the MSDU into a MAC frame and enqueues it.      
 *             
 * Input:	msdu - MSDU (MAC Frame Payload)
 *			ack - TRUE if the acknowledgment is required, otherwise FALSE
 *			dest_address - the destionation MAC address for packet
 *--------------------------------------------------------------------------------*/

static void wpan_encapsulate_and_enqueue_data_frame(Packet* msdu, Boolean ack, int dest_address) {
	
	Packet* mac_frame;	
	int seq_num;
	
	/* Stack tracing enrty point */
	FIN(wpan_encapsulate_and_enqueue_data_frame);
		
	/* create a MAC frame that encapsulates the MSDU and send it! */
	mac_frame = op_pk_create_fmt ("wpan_frame_MPDU_format");
		
	/* generate the sequence number for the packet */
	seq_num = wpan_update_sequence_number();
		
	op_pk_nfd_set (mac_frame, "Frame Type", DATA_FRAME_TYPE);
	op_pk_nfd_set (mac_frame, "Sequence Number",seq_num); 
	op_pk_nfd_set (mac_frame, "Destination PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (mac_frame, "Destination Address", dest_address);
	op_pk_nfd_set (mac_frame, "Source PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (mac_frame, "Source Address", my_attributes.mac_address);
	op_pk_nfd_set_pkt (mac_frame, "MSDU", msdu); // The MSDU is encapsulated in the MAC Data Frame
	if (ack)
		op_pk_nfd_set (mac_frame, "Ack Request", 1);	// requires ACK
	else
		op_pk_nfd_set (mac_frame, "Ack Request", 0);	// no ACK
		
	/* put it into the queue waiting for transmission */
	if (op_subq_pk_insert(SUBQ_ZERO, mac_frame, OPC_QPOS_TAIL) == OPC_QINS_OK) {
		if (enable_log) {
			fprintf (log,"t=%f  -> Enqueuing 0f MAC DATA frame [SEQ = %d, ACK? = %s] and try to send \n\n", op_sim_time(), seq_num, boolean2string(ack));
			printf (" [Node %s] t=%f  -> Enqueuing 0f MAC DATA frame [SEQ = %d, ACK? = %s] and try to send, CAP is active? = %s \n\n", my_attributes.name, op_sim_time(), seq_num, boolean2string(ack), boolean2string(SF.CAP_ACTIVE));
		}
	} else {
		if (enable_log) {
			fprintf (log,"t=%f  -> MAC DATA frame cannot be enqueuing - FRAME IS DROPPED !!!! \n\n", op_sim_time());
			printf (" [Node %s] t=%f  -> MAC DATA frame cannot be enqueuing - FRAME IS DROPPED !!!! \n\n", my_attributes.name, op_sim_time());
		}
		
		/* destroy the packet */
		op_pk_destroy (mac_frame);
	}
		 
	/* try to send the packet */
	op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);
	
	/* Stack tracing exit point */
	FOUT;	
}


/*--------------------------------------------------------------------------------
 * Function: wpan_encapsulate_and_enqueue_command_frame
 *
 * Description:	encapsulates the MSDU into a MAC frame and enqueues it.      
 *             
 * Input:	msdu - MSDU (MAC Frame payload)
 *			ack - TRUE if the acknowledgment is required, otherwise FALSE
 *			dest_address - the destionation MAC address for packet
 *--------------------------------------------------------------------------------*/

static void wpan_encapsulate_and_enqueue_command_frame(Packet* msdu, Boolean ack, int dest_address) {
	
	Packet* mac_frame;	
	int seq_num;
	
	/* Stack tracing enrty point */
	FIN(wpan_encapsulate_and_enqueue_command_frame);
		
	/* create a MAC frame that encapsulates the MSDU and send it! */
	mac_frame = op_pk_create_fmt ("wpan_frame_MPDU_format");
		
	/* generate the sequence number for the packet */
	seq_num = wpan_update_sequence_number();
		
	op_pk_nfd_set (mac_frame, "Frame Type", COMMAND_FRAME_TYPE);
	op_pk_nfd_set (mac_frame, "Sequence Number", seq_num); 
	op_pk_nfd_set (mac_frame, "Destination PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (mac_frame, "Destination Address", dest_address);
	op_pk_nfd_set (mac_frame, "Source PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (mac_frame, "Source Address", my_attributes.mac_address);
	op_pk_nfd_set_pkt (mac_frame, "MSDU", msdu); // The MSDU is encapsulated in the MAC Command Frame
	if (ack)
		op_pk_nfd_set (mac_frame, "Ack Request", 1);	// requires ACK
	else
		op_pk_nfd_set (mac_frame, "Ack Request", 0);	// no ACK
	
	
	/* put it into the queue waiting for transmission */
	if (op_subq_pk_insert(SUBQ_ZERO, mac_frame, OPC_QPOS_TAIL) == OPC_QINS_OK) {
		if (enable_log) {
			fprintf (log,"t=%f  -> Enqueuing of MAC COMMAND frame [SEQ = %d, ACK? = %s] and try to send \n\n", op_sim_time(), seq_num, boolean2string(ack));
			printf (" [Node %s] t=%f  -> Enqueuing of MAC COMMAND frame [SEQ = %d, ACK? = %s] and try to send, CAP is active? = %s \n\n", my_attributes.name, op_sim_time(), seq_num, boolean2string(ack), boolean2string(SF.CAP_ACTIVE));
		}
	} else {
		if (enable_log) {
			fprintf (log,"t=%f  -> MAC COMMAND frame cannot be enqueuing - FRAME IS DROPPED !!!! \n\n", op_sim_time());
			printf (" [Node %s] t=%f  -> MAC COMMAND frame cannot be enqueuing - FRAME IS DROPPED !!!! \n\n", my_attributes.name, op_sim_time());
		}
		
		/* destroy the packet */
		op_pk_destroy (mac_frame);
	}
		 
	/* try to send the packet */
	op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);
	
	/* Stack tracing exit point */
	FOUT;	
}


/*--------------------------------------------------------------------------------
 * Function: wpan_encapsulate_and_enqueue_gts_frame
 *
 * Description:	encapsulates the GTS MSDU into a MAC frame and enqueues it.      
 *             
 * Input:	frame_MSDU - the GTS MSDU (MAC Frame payload)
 *--------------------------------------------------------------------------------*/

static void wpan_encapsulate_and_enqueue_gts_frame(Packet* frame_MSDU) {

	Ici* iciptr;
	Packet* frame_MPDU;
	Boolean ack;
	int seq_num;	// the sequence number of the packet
	
	/* Stack tracing enrty point */
	FIN(wpan_encapsulate_and_enqueue_gts_frame);

	
	/* get the ICI information */
	iciptr = op_intrpt_ici ();
	
	op_ici_attr_get (iciptr, "Acknowledgement", &ack);			
	op_ici_destroy (iciptr);
	
	/* create a MAC frame that encapsulates the GTS MSDU and send it! */
	frame_MPDU = op_pk_create_fmt ("wpan_frame_MPDU_format");
		
	/* generate the sequence number for the packet */
	seq_num = wpan_update_sequence_number();
	
	op_pk_nfd_set (frame_MPDU, "Frame Type", DATA_FRAME_TYPE);
	op_pk_nfd_set (frame_MPDU, "Sequence Number", seq_num); 
	op_pk_nfd_set (frame_MPDU, "Destination PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (frame_MPDU, "Destination Address", my_attributes.PANcoordinator_mac_address);
	op_pk_nfd_set (frame_MPDU, "Source PAN Identifier", my_attributes.pan_id);
	op_pk_nfd_set (frame_MPDU, "Source Address", my_attributes.mac_address);
	op_pk_nfd_set_pkt (frame_MPDU, "MSDU", frame_MSDU); // The GTS MSDU is encapsulated in the MAC Frame
	if (ack)
		op_pk_nfd_set (frame_MPDU, "Ack Request", 1);	// requires ACK
	else
		op_pk_nfd_set (frame_MPDU, "Ack Request", 0);	// no ACK
	
	gts_statistics.generated_frames++;
	gts_statistics.generated_bits = gts_statistics.generated_bits + op_pk_total_size_get (frame_MSDU);
	

	/* put it into the GTS queue waiting for transmission */
	if (op_subq_pk_insert (SUBQ_GTS, frame_MPDU, OPC_QPOS_TAIL) == OPC_QINS_OK) {
		if (enable_log) {
			fprintf (log,"t=%f  -> Enqueuing of MAC GTS DATA frame [SEQ = %d, ACK? = %s] \n\t - usable GTS subqueue capacity: %.0f bits. \n\n", op_sim_time(), seq_num, boolean2string(ack), op_subq_stat (SUBQ_GTS, OPC_QSTAT_FREE_BITSIZE));
			printf (" [Node %s] t=%f  -> Enqueing of MAC GTS DATA frame [SEQ = %d, ACK? = %s] \n\t - usable GTS subqueue capacity: %.0f bits. \n\n", my_attributes.name, op_sim_time(), seq_num, boolean2string(ack), op_subq_stat (SUBQ_GTS, OPC_QSTAT_FREE_BITSIZE));
		}	
		
		op_stat_write (gts_statistic_vector.buffer_saturation_pc, (double)op_subq_stat (SUBQ_GTS, OPC_QSTAT_BITSIZE)/gts_queue_capacity);
		
		/* try to send a packet if GTS is active, the previous packet is not waiting for ACK and TX time is not active */
		if (GTS.GTS_ACTIVE && !mac_attributes.wait_ack && !is_GTS_tx_time_active)
			op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE);
		
	} else {	
		if (enable_log) {
			fprintf (log,"t=%f  -> GTS DATA frame - MPDU [size: %d bits] cannot be enqueuing \n\t - the GTS subqueue is full -> FRAME IS DROPPED !!!! \n\n", op_sim_time(), op_pk_total_size_get (frame_MPDU));
			printf (" [Node %s] t=%f  -> GTS DATA frame - MPDU [size: %d bits] cannot be enqueuing \n\t - the GTS subqueue is full -> FRAME IS DROPPED !!!! \n\n", my_attributes.name, op_sim_time(), op_pk_total_size_get (frame_MPDU));
		}
		

		if (start_GTS_transmission == OPC_FALSE) {
			start_GTS_transmission = OPC_TRUE;	// buffer is full, GTS transmission is allowed - initially full buffer
		}
		
		gts_statistics.dropped_frames++;
		gts_statistics.dropped_bits = gts_statistics.dropped_bits + op_pk_total_size_get (frame_MPDU);
		
		/* destroy the packet */
		op_pk_destroy (frame_MPDU);
	}
	
	/* Stack tracing exit point */
	FOUT;	
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_scheduling
 *
 * Description:	checks the validity of times and schedules GTS start time and stop time.
 *
 * No parameters  
 *--------------------------------------------------------------------------------*/

static void wpan_gts_scheduling() {

	/* Stack tracing enrty point */
	FIN(wpan_gts_scheduling);

	/* GTS schledule just for End Device */
	if (!my_attributes.is_PANcoordinator) {
		
		/* Make sure we have valid start and stop times, i.e. stop time is not earlier than start time.	*/
		if ((GTS.stop_time <= GTS.start_time) && (GTS.stop_time != INFINITE_TIME)) {
			
			/* Stop time is earlier than start time. Disable the GTS. */
			GTS.start_time = INFINITE_TIME;

			/* Display an appropriate warning. */
			op_prg_odb_print_major ("Warning - the GTS scheduling: \n A start time must be before stop time. \n Disabled GTS.", OPC_NIL);
		}
	
		/* Schedule a self interrupt. */
		if ((GTS.start_time != INFINITE_TIME) && (GTS.length > 0)) {
		
			if (GTS.start_time == 0) {				
				op_intrpt_schedule_self (GTS.start_time+0.000001, START_OF_GTS_USE);
			}
			else {
				op_intrpt_schedule_self (GTS.start_time, START_OF_GTS_USE);
			}
		
			if (GTS.stop_time != INFINITE_TIME)
				op_intrpt_schedule_self (GTS.stop_time, STOP_OF_GTS_USE);

			if (enable_log) {
				if (GTS.stop_time == INFINITE_TIME) {
					fprintf (log,"t=%f  -> Using of the GTS is scheduled from %f sec (allocation) to INFINITE (deallocation). \n\n", op_sim_time(), GTS.start_time);
					printf (" [Node %s] t=%f  -> Using of the GTS is scheduled from %f sec (allocation) to INFINITE (deallocation). \n\n", my_attributes.name, op_sim_time(), GTS.start_time);
				}
				else {
					fprintf (log,"t=%f  -> Using of the GTS is scheduled from %f sec (allocation) to %f sec (deallocation). \n\n", op_sim_time(), GTS.start_time, GTS.stop_time);
					printf (" [Node %s] t=%f  -> Using of the GTS is scheduled from %f sec (allocation) to %f sec (deallocation). \n\n", my_attributes.name, op_sim_time(), GTS.start_time, GTS.stop_time);
				}
			}
		} else {
			if (enable_log) {
				fprintf (log,"t=%f  -> The GTS will not be used because the GTS.start_time is INFINITE or GTS.length is 0. \n\n", op_sim_time());
				printf (" [Node %s] t=%f  -> The GTS will not be used because the GTS.start_time is INFINITE or GTS.length is 0. \n\n", my_attributes.name, op_sim_time());
			}
		}
		
	}
	
	/* Stack tracing exit point */
	FOUT;	
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_allocation_request
 *
 * Description:	creates GTS Request command for GTS allocation. It will be send to PANCoordinator.
 *
 * No parameters  
 *--------------------------------------------------------------------------------*/

static void wpan_gts_allocation_request() {

	Packet* command_MSDU;
	wpan_gts_characteristics* gts_characteristics_ptr;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_allocation_request);

	/* convert number of bits to actual number of superframe slots */
	//nbr_slots = ceil(ceil(GTS.length/Symbol2Bits)/SF.slot_duration);

	/* memory allocation */
	gts_characteristics_ptr = (wpan_gts_characteristics *) op_prg_mem_alloc (sizeof(wpan_gts_characteristics));
	
	gts_characteristics_ptr->length = GTS.length;
	gts_characteristics_ptr->direction = GTS.direction;
	gts_characteristics_ptr->characteristics_type = GTS_ALLOCATION;
	
	/* create a GTS request COMMAND MSDU */
	command_MSDU = op_pk_create_fmt ("wpan_command_MSDU_format");	
	op_pk_nfd_set (command_MSDU, "Command Frame Identifier", GTS_REQ);
	op_pk_nfd_set_ptr (command_MSDU, "Command Payload", gts_characteristics_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (wpan_gts_characteristics));
	
	/* set the appropriate size of the payload according the specifiaction */
	op_pk_bulk_size_set (command_MSDU, 8); // the size of the GTS characteristics field is 8 bits
	
	if (enable_log) {
		fprintf(log,"t=%f  -> ---- GTS ALLOCATION - created GTS request command [GTS_length=%d slots, GTS_direction=%d]. \n\n", op_sim_time(), GTS.length, GTS.direction);
		printf(" [Node %s] t=%f  -> --- GTS ALLOCATION - created GTS request command [GTS_length=%d slots, GTS_direction=%d]. \n\n", my_attributes.name, op_sim_time(), GTS.length, GTS.direction);
	}
	
	/* encapsulate and enqueue GTS request command frame */
	wpan_encapsulate_and_enqueue_command_frame (command_MSDU, OPC_TRUE, my_attributes.PANcoordinator_mac_address);	
	
	/* waiting for the reply in the beacon frame from the PANCoordinator */
	is_waiting_GTS_confirm = OPC_TRUE;
	
	/* Stack tracing exit point */
	FOUT;	
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_deallocation_request
 *
 * Description:	creates GTS Request command for GTS deallocation. It will be send to PANCoordinator.
 *
 * No parameters  
 *--------------------------------------------------------------------------------*/

static void wpan_gts_deallocation_request() {

	Packet* command_frame;
	wpan_gts_characteristics* gts_characteristics_ptr;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_deallocation_request);

	/* convert number of bits to actual number of superframe slots */
	//nbr_slots = ceil(ceil(GTS.length/Symbol2Bits)/SF.slot_duration);

	/* memory allocation */
	gts_characteristics_ptr = (wpan_gts_characteristics *) op_prg_mem_alloc (sizeof(wpan_gts_characteristics));
	
	gts_characteristics_ptr->length = GTS.length;
	gts_characteristics_ptr->direction = GTS.direction;
	gts_characteristics_ptr->characteristics_type = GTS_DEALLOCATION;
	
	/* create a GTS request COMMAND frame */
	command_frame = op_pk_create_fmt ("wpan_command_MSDU_format");	
	op_pk_nfd_set (command_frame, "Command Frame Identifier", GTS_REQ);
	op_pk_nfd_set_ptr (command_frame, "Command Payload", gts_characteristics_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (wpan_gts_characteristics));
	
	/* set the appropriate size of the payload according the specifiaction */
	op_pk_bulk_size_set (command_frame, 8); // the size of the GTS characteristics field is 8 bits
	
	if (enable_log) {
		fprintf(log,"t=%f  -> --- GTS DEALLOCATION - created GTS request command [GTS_length=%d slots, GTS_direction=%d]. \n\n", op_sim_time(), GTS.length, GTS.direction);
		printf(" [Node %s] t=%f  -> --- GTS DEALLOCATION - created GTS request command [GTS_length=%d slots, GTS_direction=%d]. \n\n", my_attributes.name, op_sim_time(), GTS.length, GTS.direction);
	}
	
	/* encapsulate and enqueue GTS request command frame */
	wpan_encapsulate_and_enqueue_command_frame (command_frame, OPC_TRUE, my_attributes.PANcoordinator_mac_address);	
	
	is_deallocation_req_sent = OPC_TRUE;
	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_reallocation_request
 *
 * Description:	update GTS_list_PC list i.e. remove gaps from CFP.
 *
 * No parameters    
 *--------------------------------------------------------------------------------*/

static void wpan_gts_reallocation_request() {

	wpan_gts_list_PC_record * gts_list_PC_record_ptr; // GTS structure storing in the GTS_list_PC
	int i;
	int last_start_slot = TIME_SLOT_INDEX_MAX+1;
	int changes_count = 0;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_reallocation_request);
	
	for (i=(op_prg_list_size (my_attributes.GTS_list_PC)-1); i>=0; i--) {

		gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_list_access (my_attributes.GTS_list_PC, i);
		
		if ((gts_list_PC_record_ptr->start_slot == 0) && (gts_list_PC_record_ptr->beacon_persistence_time == 0)) {
			/* remove information record for the unallocated GTS */
			op_prg_list_remove (my_attributes.GTS_list_PC, i);
			changes_count = changes_count + 1;
		} else if (gts_list_PC_record_ptr->start_slot >0) {
			if (gts_list_PC_record_ptr->start_slot != (last_start_slot - gts_list_PC_record_ptr->length)) {
				/* update start slot */
				gts_list_PC_record_ptr->start_slot = last_start_slot - gts_list_PC_record_ptr->length;
				
				/* propagate changes in the following beacons */
				gts_list_PC_record_ptr->beacon_persistence_time = aGTSDescPersistenceTime;	
				
				changes_count = changes_count + 1;
			} 
			
			last_start_slot = gts_list_PC_record_ptr->start_slot;
		}
	}
	
	/* update Final_CAP_slot value for next superframe*/
	Final_CAP_slot_next = last_start_slot-1;
	
	if (enable_log && (changes_count>0)) {
		fprintf(log,"t=%f  -> GTS realocation - GTS list was updated (%d changes) - Final CAP slot = %d. \n\n", op_sim_time(), changes_count, Final_CAP_slot_next);
		printf(" [Node %s] t=%f  -> GTS realocation - GTS list was updated (%d changes)- Final CAP slot = %d. \n\n", my_attributes.name, op_sim_time(), changes_count, Final_CAP_slot_next);
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_gts_request_extract
 *
 * Description:	extract incoming GTS request command and allocate appropriate GTS if
 *				there are available resources in actual superframe.
 *
 * Input :	mac_frame - received GTS request command 
 *--------------------------------------------------------------------------------*/

static void wpan_gts_request_extract(Packet* mac_frame) {

	Packet* command_frame;
	wpan_gts_characteristics* gts_characteristics_ptr;	// GTS structure receiving from the command frame
	wpan_gts_list_PC_record * gts_list_PC_record_ptr; // GTS structure storing in the GTS_list_PC
	int source_address;
	int min_space; // [symbols]
	int i;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_request_extract);
	
	/* obtain packet source address */
	op_pk_nfd_get (mac_frame, "Source Address", &source_address);
	
	/* obtain GTS characteristics field (Command Payload) */
	op_pk_nfd_get_pkt (mac_frame, "MSDU", &command_frame);
	
	/* obtain GTS characteristics values */
	op_pk_nfd_get (command_frame, "Command Payload", &gts_characteristics_ptr);		
	
	/* minimum superframe space which must stay unused */
	min_space = aMinCAPLength + (PHY_HEADER_SIZE+BEACON_HEADER_SIZE+BEACON_MSDU_SIZE)/Symbol2Bits; //[symbols]
	
	if (gts_characteristics_ptr->characteristics_type == GTS_ALLOCATION) { /* allocation of GTS slot(s) */	
		
		/* check the available space in the GTS list */
		if (op_prg_list_size (my_attributes.GTS_list_PC) >= 7) {	// up to 7 GTSs can be allocated
			if (enable_log == OPC_TRUE) {
				fprintf (log, "t=%f  -> Received GTS request command for ALLOCATION from node @%d \n\t !!! GTS cannot be allocated because maximum number (7) of GTSs has been reached.\n\n", op_sim_time(), source_address);
				printf (" [Node %s] t=%f  -> Received GTS request command for ALLOCATION from node @%d \n\t !!! GTS cannot be allocated because maximum number (7) of GTSs has been reached.\n\n", my_attributes.name, op_sim_time(), source_address);
			}		
		} else { /* the size of GTS_list_PC != 7 */
			if (((Final_CAP_slot_next-gts_characteristics_ptr->length+1)*SF.slot_duration) < min_space) {	/* not enough space in superframe CAP */
				
				/* memory allocation */
				gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_mem_alloc (sizeof (wpan_gts_list_PC_record));
				
				gts_list_PC_record_ptr->start_slot = 0; 
				gts_list_PC_record_ptr->length = Final_CAP_slot_next - (int)ceil((double)min_space/SF.slot_duration); // available number of slots
				gts_list_PC_record_ptr->direction = gts_characteristics_ptr->direction;
				gts_list_PC_record_ptr->assoc_dev_address = source_address;
				gts_list_PC_record_ptr->beacon_persistence_time = aGTSDescPersistenceTime;	// propagate changes in the following beacons 
				
				/* insert the GTS parameter record onto the list head */
				op_prg_list_insert (my_attributes.GTS_list_PC, gts_list_PC_record_ptr, OPC_LISTPOS_HEAD);				
			
				if (enable_log == OPC_TRUE) {
					fprintf (log, "t=%f  -> Received GTS request command for ALLOCATION from node @%d \n\t !!! GTS cannot be allocated because there is not enough space in CAP [only %d available slot(s)].\n\n", op_sim_time(), source_address, gts_list_PC_record_ptr->length);
					printf (" [Node %s] t=%f  -> Received GTS request command for ALLOCATION from node @%d \n\t !!! GTS cannot be allocated because there is not enough space in CAP [only %d available slot(s)].\n\n", my_attributes.name, op_sim_time(), source_address, gts_list_PC_record_ptr->length);
				}
			} else { /* GTS can be allocated */
				
				/* update Final_CAP_slot value for next superframe*/
				Final_CAP_slot_next = Final_CAP_slot_next-gts_characteristics_ptr->length;
				
				/* memory allocation */
				gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_mem_alloc (sizeof (wpan_gts_list_PC_record));
				
				gts_list_PC_record_ptr->start_slot = Final_CAP_slot_next+1;
				gts_list_PC_record_ptr->length = gts_characteristics_ptr->length;
				gts_list_PC_record_ptr->direction = gts_characteristics_ptr->direction;
				gts_list_PC_record_ptr->assoc_dev_address = source_address;
				gts_list_PC_record_ptr->beacon_persistence_time = aGTSDescPersistenceTime;	// propagate changes in the following beacons 
				
				/* insert the GTS parameter record onto the list head */
				op_prg_list_insert (my_attributes.GTS_list_PC, gts_list_PC_record_ptr, OPC_LISTPOS_HEAD);
				
				if (enable_log) {									
					printf (" [Node %s] t=%f  ->  Received GTS request command for ALLOCATION \n", my_attributes.name, op_sim_time());
					printf ("\t GTS slots for node @%d can be allocated - there are available resources in the actual superframe. \n ", gts_list_PC_record_ptr->assoc_dev_address);
					printf ("\t\t + Start slot       = %d \n", gts_list_PC_record_ptr->start_slot); 
					printf ("\t\t + Length of GTS    = %d slots \n", gts_list_PC_record_ptr->length);
					printf ("\t\t + Direction of GTS = %d (device->PANCoord=0, PANCoord->device=1) \n\n", gts_list_PC_record_ptr->direction);
					printf ("\t Number of GTSs = %d \n", op_prg_list_size (my_attributes.GTS_list_PC));
					printf ("\t Final CAP slot = %d \n\n", Final_CAP_slot_next);
					
					fprintf (log, "t=%f  ->  Received GTS request command for ALLOCATION \n", op_sim_time());
					fprintf (log, "\t GTS slots for node @%d can be allocated - there are available resources in the actual superframe. \n ", gts_list_PC_record_ptr->assoc_dev_address);
					fprintf (log, "\t\t + Start slot       = %d \n", gts_list_PC_record_ptr->start_slot); 
					fprintf (log, "\t\t + Length of GTS    = %d slots \n", gts_list_PC_record_ptr->length);
					fprintf (log, "\t\t + Direction of GTS = %d (device->PANCoord=0, PANCoord->device=1) \n\n", gts_list_PC_record_ptr->direction);
					fprintf (log, "\t Number of GTSs = %d \n", op_prg_list_size (my_attributes.GTS_list_PC));
					fprintf (log, "\t Final CAP slot = %d \n\n", Final_CAP_slot_next);
				}				
			}
		}	
	} else { /* deallocation of GTS slot(s) */
		
		if (enable_log) {
			fprintf (log,"t=%f  -> Received GTS request command from node @%d for DEALLOCATION. \n\n", op_sim_time(), source_address);
			printf (" [Node %s] t=%f  -> Received GTS request command from node @%d for DEALLOCATION. \n\n", my_attributes.name, op_sim_time(), source_address);
		}
		
		/* find the appropriate GTS_list_PC record for given device */
		for (i=0; i<op_prg_list_size (my_attributes.GTS_list_PC); i++) {
			gts_list_PC_record_ptr = (wpan_gts_list_PC_record *) op_prg_list_access (my_attributes.GTS_list_PC, i);
			
			/* check the device GTS charackteristics from the received request with the GTS_list_PC record - there can be 2 GTSs for each device (transmit, receive) */
			if ((gts_list_PC_record_ptr->assoc_dev_address == source_address) && (gts_list_PC_record_ptr->direction == gts_characteristics_ptr->direction)) {
				
				/* remove the record from the GTS_list. */
				if (op_prg_list_remove (my_attributes.GTS_list_PC, i) != OPC_NIL) {
					/* update Final_CAP_slot value for next superframe */
					Final_CAP_slot_next = Final_CAP_slot_next+gts_list_PC_record_ptr->length;
					
					if (enable_log) {
						fprintf (log,"t=%f  -> The GTS record (Address: %d, Length: %d, Direction: %d) was successfully removed from the list. \n", op_sim_time(), gts_list_PC_record_ptr->assoc_dev_address, gts_list_PC_record_ptr->length, gts_list_PC_record_ptr->direction);
						fprintf (log,"\t  + updated Final_CAP_slot = %d \n\n", Final_CAP_slot_next);
						
						printf (" [Node %s] t=%f  -> The GTS record (Address: %d, Length: %d, Direction: %d) was successfully removed from the list. \n", my_attributes.name, op_sim_time(), gts_list_PC_record_ptr->assoc_dev_address, gts_list_PC_record_ptr->length, gts_list_PC_record_ptr->direction);;
						printf ("\t  + updated Final_CAP_slot = %d \n\n", Final_CAP_slot_next);
					}
					
					/* reallocate the GTS_list_PC */
					wpan_gts_reallocation_request ();				
				} else {
					if (enable_log) {
						fprintf (log,"t=%f  -> WARNING - the appropriate record from GTS_list cannot be remove!!! \n\n", op_sim_time());
						printf (" [Node %s] t=%f  -> WARNING - the appropriate record from GTS_list cannot be remove!!! \n\n", my_attributes.name, op_sim_time());
					}				
				}		
			}
		}				
	}
	
	/* memory deallocation */
	op_prg_mem_free (gts_characteristics_ptr);
	
	/* destroy the packets */
	op_pk_destroy (command_frame);
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function: wpan_gts_slot_init
 *
 * Description:	initialization of the GTS transmission slot      
 *             
 * No parameters  
 *--------------------------------------------------------------------------------*/
static void wpan_gts_slot_init() {

	/* Stack tracing enrty point */
	FIN(wpan_gts_slot_init);

	if (enable_log) {	 
		fprintf(log,"t=%f  ->  GTS Subqueue contains %.0f packets (MPDU) and %.0f bits. \n\n", op_sim_time(), op_subq_stat (SUBQ_GTS, OPC_QSTAT_PKSIZE), op_subq_stat (SUBQ_GTS, OPC_QSTAT_BITSIZE));
		printf(" [Node %s] t=%f  -> GTS Subqueue contains %.0f packets (MPDU) and %.0f bits. \n\n", my_attributes.name, op_sim_time(), op_subq_stat (SUBQ_GTS, OPC_QSTAT_PKSIZE), op_subq_stat (SUBQ_GTS, OPC_QSTAT_BITSIZE));
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function: wpan_gts_check_time
 *
 * Description:	check if the requested transaction can be completed before the end of the current current GTS  
 *					|PHY|FRAME|-||macAckWaitDuration + |PHY|ACK||-|IFS| or
 *					|PHY|FRAME|-|IFS| or
 *             
 * Input: frame_MPDU - the pointer to the frame (MPDU) which should be send
 *
 * Output: TRUE if there is enough time in the actual GTS period
 *
 *--------------------------------------------------------------------------------*/

static Boolean wpan_gts_check_time(Packet* frame_MPDU) {

	int frame_len_Symbol;
	int IFS;
	Boolean ack_request;
	double end_gts_time;
	double remaining_gts_time;
	double tx_time;
	double ack_time_Symbol;
	
	/* Stack tracing enrty point */
	FIN(wpan_gts_check_time);

	/* get the frame size*/
	frame_len_Symbol = Bits2Symbols((int) op_pk_total_size_get(frame_MPDU));
	
	/* get the corresponding IFS of the frame*/
	IFS = wpan_ifs_symbol_get(frame_MPDU);
	
	/* check if any acknowledgment is necessary for this frame */
	op_pk_nfd_get (frame_MPDU, "Ack Request", &ack_request);
	
	if (ack_request)
		ack_time_Symbol = macAckWaitDuration+Bits2Symbols(ACK_FRAME_SIZE_BITS)+Bits2Symbols(PHY_HEADER_SIZE);
		//ack_time_Symbol = aTurnaroundTime_Symbol+Bits2Symbols(ACK_FRAME_SIZE_BITS)+Bits2Symbols(PHY_HEADER_SIZE);
	else 
		ack_time_Symbol = 0;	
	
	
	/* time of the end of the GTS */
	end_gts_time = SF.BI_Boundary + Symbols2Sec((GTS.start_slot*SF.slot_duration), WPAN_DATA_RATE) + Symbols2Sec((GTS.length*SF.slot_duration), WPAN_DATA_RATE);
	remaining_gts_time = end_gts_time - op_sim_time();
	
	/* |PHY|FRAME|-||macAckWaitDuration + |PHY|ACK||-|IFS| or |PHY|FRAME|-|IFS|  */
	tx_time = Symbols2Sec((Bits2Symbols(PHY_HEADER_SIZE)+frame_len_Symbol+ack_time_Symbol+IFS), WPAN_DATA_RATE);
	
	/* check the time for packet transmission */
	if (tx_time <= remaining_gts_time) {	
		return OPC_TRUE;
		
		/* Stack tracing exit point */
		FRET(OPC_TRUE);
	}
	else { 	
		return OPC_FALSE;
		
		/* Stack tracing exit point */
		FRET(OPC_FALSE);
	}
}


/*--------------------------------------------------------------------------------
 * Function: wpan_mac_interrupt_process
 *
 * Description:	processes all the interrupts that occurs in an unforced state      
 *             
 * No parameters  
 *--------------------------------------------------------------------------------*/

static void wpan_mac_interrupt_process() {
	
	Packet* frame_MPDU;
	Packet* frame_MPDU_copy;
	Packet* frame_MPDU_to_send;
	Packet* frame_PPDU;
	Packet* ack_MPDU;
	double tx_time;
	int ack_request;
	int seq_num;
	int dest_address;
	
	/* Stack tracing enrty point */
	FIN(wpan_mac_interrupt_process);
	
	switch (op_intrpt_type()) {
	
		case OPC_INTRPT_STRM: // incomming packet 
		{			
			wpan_parse_incoming_frame ();	// parse the incoming packet		
			break;
		};/*end of OPC_INTRPT_STRM */	
	
		case OPC_INTRPT_SELF: 
		{			
			switch (op_intrpt_code()) { /* begin switch (op_intrpt_code()) */ 			
				case BEACON_INTERVAL_CODE: /* Beacon Interval Expiration - end of the Beacon Interval and start of a new one */
				{
					if (enable_log) {
						fprintf (log,"t=%f  -> ++++++++++ END OF SLEEP PERIOD ++++++++++ \n\n", op_sim_time());
						printf (" [Node %s] t=%f  -> ++++++++++  END OF SLEEP PERIOD ++++++++++ \n\n", my_attributes.name, op_sim_time());
					}
					
					if (IAM_PAN_COORDINATOR) {
						SF.Final_CAP_Slot = Final_CAP_slot_next; /* value for the next superframe. End Device will obtain this value from beacon */
						wpan_send_beacon_frame();						
					}
					break;
				};/*end of BEACON_INTERVAL_CODE */
			
				case START_OF_CAP_PERIOD_CODE: /* start of Contention Access Period */
				{
					SF.current_slot = 0;
					SF.CAP_ACTIVE = OPC_TRUE;
					SF.CFP_ACTIVE = OPC_FALSE;
					SF.SLEEP = OPC_FALSE;
					GTS.GTS_ACTIVE = OPC_FALSE;					
				
					if (enable_log) {
						fprintf (log,"t=%f  -> ++++++++++ START OF THE CAP ++++++++++ \n\n", op_sim_time());
						printf (" [Node %s] t=%f  -> ++++++++++  START OF THE CAP ++++++++++ \n\n", my_attributes.name, op_sim_time());
					}
				
					/* if a backoff timer was paused during the previous CAP, it is resumed in this CAP*/
					if (SF.RESUME_BACKOFF_TIMER == OPC_TRUE) {						
						if (enable_log) {
							fprintf (log,"t=%f  -> RESUME A BACKOFF [%f] + BACKOFF BOUNDARY [%f] = EXPIRE AT %f sec  %f\n\n", op_sim_time(), SF.backoff_timer, wpan_backoff_period_boundary_get(), wpan_backoff_period_boundary_get()+SF.backoff_timer);
							printf (" [Node %s] t=%f  ->  RESUME A BACKOFF [%f] + BACKOFF BOUNDARY [%f] = EXPIRE AT %f sec    \n\n", my_attributes.name, op_sim_time(), SF.backoff_timer, wpan_backoff_period_boundary_get(), wpan_backoff_period_boundary_get()+SF.backoff_timer);
						}
						
						op_intrpt_schedule_self (wpan_backoff_period_boundary_get()+SF.backoff_timer, BACKOFF_EXPIRATION_CODE);
					}
	
					/* if a CCA is deferred, it shall be resumed at the begining of the CAP of the superframe*/
					if (SF.CCA_DEFERRED == OPC_TRUE) {
						if (enable_log) {
							fprintf (log,"t=%f  -> RESUME THE CCA OPERATION (CCA WAS DEFERRED IN LAST CAP)  \n\n", op_sim_time());
							printf(" [Node %s] t=%f  -> RESUME THE CCA OPERATION (CCA WAS DEFERRED IN LAST CAP)    \n\n", my_attributes.name, op_sim_time());
						}
					
						SF.CCA_DEFERRED = OPC_FALSE;
						wpan_cca_perform (3);
					}
				
					op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);				
					break;
				};/* end of START_OF_CAP_PERIOD_CODE */
			
				case END_OF_CAP_PERIOD_CODE:	/* the end of the CAP Expiration */	
				{
					SF.current_slot = SF.Final_CAP_Slot;
					SF.CAP_ACTIVE = OPC_FALSE;								
										
					/* the end of the CAP is the end of the superframe -> enter into sleep state*/
					if (SF.Final_CAP_Slot == TIME_SLOT_INDEX_MAX) { 
						SF.CFP_ACTIVE = OPC_FALSE;
						SF.SLEEP = OPC_TRUE;
						
						if (enable_log) {
							fprintf (log,"t=%f  -> ++++++++++ END OF THE CAP PERIOD - GOING INTO SLEEP PERIOD ++++++++++ \n\n", op_sim_time());
							printf (" [Node %s] t=%f  -> ++++++++++  END OF THE CAP PERIOD - GOING INTO SLEEP PERIOD ++++++++++ \n\n", my_attributes.name, op_sim_time());
						}	
						
						/*Inform the Battery Module that the node enters the SLEEP state*/
						op_intrpt_schedule_remote (op_sim_time(), END_OF_ACTIVE_PERIOD_CODE, my_attributes.my_battery);
						
					} else { /* if there is still available slots in the superframe for the CFP period */
						SF.CFP_ACTIVE = OPC_TRUE;
						SF.SLEEP = OPC_FALSE;
						
						if (enable_log) {
							fprintf (log,"t=%f  -> ++++++++++ END OF THE CAP PERIOD - GOING INTO CFP PERIOD ++++++++++ \n\n", op_sim_time());
							printf (" [Node %s] t=%f  -> ++++++++++  END OF THE CAP PERIOD - GOING INTO CFP PERIOD ++++++++++ \n\n", my_attributes.name, op_sim_time());
						}	

						//op_intrpt_priority_set (OPC_INTRPT_SELF, END_OF_CFP_PERIOD_CODE, -2);
						op_intrpt_schedule_self (SF.BI_Boundary+Symbols2Sec(((TIME_SLOT_INDEX_MAX+1)*SF.slot_duration), WPAN_DATA_RATE), END_OF_CFP_PERIOD_CODE);
					}
						
					break;
				};/*end of END_OF_CAP_PERIOD_CODE */
			
				case END_OF_CFP_PERIOD_CODE :	/* the end of the CFP Expiration */
				{
					SF.current_slot = TIME_SLOT_INDEX_MAX;
					SF.CAP_ACTIVE = OPC_FALSE;
					SF.CFP_ACTIVE = OPC_FALSE;
					SF.SLEEP = OPC_TRUE;
					
					if (enable_log) {
						fprintf (log,"t=%f  -> ++++++++++ END OF THE CFP PERIOD - GOING INTO SLEEP PERIOD ++++++++++ \n\n", op_sim_time());
						printf (" [Node %s] t=%f  -> ++++++++++  END OF THE CFP PERIOD - GOING INTO SLEEP PERIOD ++++++++++ \n\n", my_attributes.name, op_sim_time());
					}						
					
					/*Inform the Battery Module that the node enters the SLEEP state*/
					op_intrpt_schedule_remote (op_sim_time(), END_OF_ACTIVE_PERIOD_CODE, my_attributes.my_battery);
					
					break;
				};/*end of END_OF_CFP_PERIOD_CODE */
			
				case TRY_PACKET_TRANSMISSION_CODE :
				{
					/* do nothing */
					break;
				};
			
				case CCA_START_CODE: /*At the start of the CCA */
				{
					/* do check if the channel is idle at the start of cca */
					/* at the start the channel is assumed idle, any change to busy, the CCA will report a busy channel */
				
					/* check at the beginning of CCA, if the channel is busy */
					csma.CCA_CHANNEL_IDLE = OPC_TRUE;
					if (op_stat_local_read (RX_BUSY_STAT) == 1.0)
						csma.CCA_CHANNEL_IDLE = OPC_FALSE;
					
					if (enable_log) {
						fprintf (log,"t=%f  -------- START CCA CW = %d ------>  CHANNEL IDLE = %s  \n\n",op_sim_time(),csma.CW, boolean2string(csma.CCA_CHANNEL_IDLE));
						printf (" [Node %s] t=%f  -------- START CCA CW = %d ------>  CHANNEL IDLE = %s  \n\n",my_attributes.name,op_sim_time(), csma.CW, boolean2string(csma.CCA_CHANNEL_IDLE));
					}
	
					if (csma.CW == 2) {
						op_stat_write(statistic_vector.ch_busy_cca1, 1-csma.CCA_CHANNEL_IDLE);
						op_stat_write(statistic_vector.ch_idle_cca1, csma.CCA_CHANNEL_IDLE);
					} else {
						op_stat_write(statistic_vector.ch_busy_cca2, 1-csma.CCA_CHANNEL_IDLE);
						op_stat_write(statistic_vector.ch_idle_cca2, csma.CCA_CHANNEL_IDLE);
					}
					break;
				};/*end of CCA_START_CODE */
			
				case CCA_EXPIRATION_CODE :/*At the end of the CCA */
				{
					wpan_cca_expire ();
					break;
				};
			
				case START_TRANSMISSION_CODE: /* successful end of backoff and CCA or GTS period */
				{	
					/*backoff_start_time is initialized in the "init_backoff" state*/
					op_stat_write(statistic_vector.mac_delay, op_sim_time()-backoff_start_time);
					op_stat_write(statistic_global_vector.mac_delay, op_sim_time()-backoff_start_time);
					
					/* obtain the pointer to MAC frame (MPDU) stored in the adequate queue */
					frame_MPDU = op_subq_pk_access (SUBQ_ZERO, OPC_QPOS_HEAD);
					op_pk_nfd_get(frame_MPDU, "Sequence Number", &seq_num);
					op_pk_nfd_get(frame_MPDU, "Ack Request", &ack_request);
					op_pk_nfd_get(frame_MPDU, "Destination Address", &dest_address);
					
					/* for frame enqueued to subqueue before first beacon reception */
					if (dest_address == PAN_COORDINATOR_ADDRESS) {
						op_pk_nfd_set(frame_MPDU, "Destination Address", my_attributes.traffic_destination_address);
						op_pk_nfd_set(frame_MPDU, "Destination PAN Identifier", my_attributes.pan_id);
						op_pk_nfd_set(frame_MPDU, "Source PAN Identifier", my_attributes.pan_id);
						dest_address = my_attributes.traffic_destination_address;
					}
					
					if (ack_request == 0) { // packet without ACK
						
						if (enable_log) {
							fprintf(log,"t=%f   ----------- START TX [DEST_ADDR = %d, SEQ = %d, no ACK] %d retries \n\n", op_sim_time(), dest_address, seq_num, csma.retries_nbr);
							printf(" [Node %s] t=%f  ----------- START TX [DEST_ADDR = %d, SEQ = %d, no ACK] %d retries \n\n", my_attributes.name, op_sim_time(), dest_address, seq_num, csma.retries_nbr);
						}
					
						op_stat_write(statistic_vector.mac_delay_unack_frame, op_sim_time()-backoff_start_time);
						op_stat_write(statistic_global_vector.mac_delay_unack_frame, op_sim_time()-backoff_start_time);
						op_stat_write(statistic_vector.retransmission_attempts, csma.retries_nbr);
						csma.retries_nbr = 0;
						mac_attributes.wait_ack = OPC_FALSE;
						
						/* remove packet at the head of subqueue */
						frame_MPDU_to_send = op_subq_pk_remove (SUBQ_ZERO, OPC_QPOS_HEAD); 
						
						/* create PHY frame (PPDU) that encapsulates MAC frame (MPDU) */
						frame_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
						
						/* wrap MAC frame (MPDU) in PHY frame (PPDU) */
						op_pk_nfd_set_pkt (frame_PPDU, "PSDU", frame_MPDU_to_send); 
						op_pk_nfd_set (frame_PPDU, "Frame Length", ((double) op_pk_total_size_get(frame_MPDU_to_send))/8); //[bytes]
						
						/* |PACKET|+|IFS| */
						tx_time = Bits2Sec (op_pk_total_size_get(frame_PPDU), WPAN_DATA_RATE) + Symbols2Sec(wpan_ifs_symbol_get(frame_MPDU_to_send), WPAN_DATA_RATE);
						op_intrpt_schedule_self (op_sim_time()+tx_time, SUCCESS_CODE);
					
						wpan_battery_update_tx((double)op_pk_total_size_get(frame_PPDU));
					
						op_stat_write(statistic_global_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
						op_stat_write(statistic_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
						
						//PPDU_sent_bits = PPDU_sent_bits + ((double)(op_pk_total_size_get(frame_PPDU))/1000.0); // in kbits
						
						op_pk_send(frame_PPDU, STRM_FROM_MAC_TO_RADIO);	
						
					} else {	// packet with ACK
						op_stat_write(statistic_vector.mac_delay_ack_frame, op_sim_time()-backoff_start_time);
						op_stat_write(statistic_global_vector.mac_delay_ack_frame, op_sim_time()-backoff_start_time);
						
						mac_attributes.wait_ack = OPC_TRUE;						
						
						frame_MPDU_copy = op_pk_copy(frame_MPDU); // create copy of queued frame
						
						/* put in memory the requested ack seq number */
						op_pk_nfd_get(frame_MPDU_copy, "Sequence Number", &mac_attributes.wait_ack_seq_num);
						
						/* create PHY frame (PPDU) that encapsulates MAC frame (MPDU) */
						frame_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
						
						/* wrap MAC frame (MPDU) in PHY frame (PPDU) */
						op_pk_nfd_set_pkt (frame_PPDU, "PSDU", frame_MPDU_copy); 
						op_pk_nfd_set (frame_PPDU, "Frame Length", ((double) op_pk_total_size_get(frame_MPDU_copy))/8); //[bytes]	
	
						/* |PACKET| */
						tx_time = Bits2Sec(op_pk_total_size_get(frame_PPDU), WPAN_DATA_RATE);
						
						op_intrpt_schedule_self (op_sim_time()+tx_time, SUCCESS_CODE);
						op_intrpt_schedule_self (op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE), WAITING_ACK_END_CODE);
						
						if (enable_log) {
							fprintf(log,"t=%f   ----------- START TX [DEST_ADDR = %d, SEQ = %d, with ACK expiring at %f] %d retries  \n\n", op_sim_time(), dest_address, mac_attributes.wait_ack_seq_num, op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE),csma.retries_nbr);
							printf(" [Node %s] t=%f  ----------- START TX [DEST_ADDR = %d, SEQ = %d, with ACK expiring at %f] %d retries \n\n", my_attributes.name, op_sim_time(), dest_address, mac_attributes.wait_ack_seq_num, op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE),csma.retries_nbr);
						}
						
						wpan_battery_update_tx((double)op_pk_total_size_get(frame_PPDU));
						
						//PPDU_sent_bits = PPDU_sent_bits + ((double)(op_pk_total_size_get(frame_PPDU))/1000.0); // in kbits
						
						op_stat_write(statistic_global_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
						op_stat_write(statistic_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
						
						op_pk_send(frame_PPDU, STRM_FROM_MAC_TO_RADIO);	
					}					
		
					break;
				}; /*end of START_TRANSMISSION_CODE */
			
				case WAITING_ACK_END_CODE:	/* the timer for waiting an ACK has expired, the packet must be retransmitted */
				{
					if (mac_attributes.wait_ack == OPC_TRUE) {
						/* I'm still waiting for the ACK and the timer expires, try to send the same packet*/
						mac_attributes.wait_ack = OPC_FALSE;
						
						if (enable_log) {
							fprintf(log,"t=%f   -> WAITING ACK TIMER EXPIRED WITHOUT RECEIVING ACK FRAME !!  \n\n",op_sim_time());							
							printf(" [Node %s] t=%f  -> WAITING ACK TIMER EXPIRED WITHOUT RECEIVING ACK FRAME !! \n\n",my_attributes.name, op_sim_time());
						}
						
						/*try_to_send the same packet*/
						op_intrpt_schedule_self (op_sim_time(), ACK_FAILURE_CODE);						
			
					} else {
						op_sim_end("WAITING_ACK_END_CODE without WAITING AN ACK","","","");
					}
					
					break;				
				}; /*end of WAITING_ACK_END_CODE */
			
				case ACK_SEND_CODE: /* send ACK back to the source */
				{
					if (enable_log) {
						fprintf(log,"t=%f  -> Send ACK Frame [SEQ = %d] \n\n", op_sim_time(), ack_sequence_number);
						printf(" [Node %s] t=%f  -> Send ACK Frame [SEQ = %d] \n\n", my_attributes.name, op_sim_time(), ack_sequence_number);
					}
						
					if (op_stat_local_read(TX_BUSY_STAT) == 1.0)
							op_sim_end("ERROR : TRY TO SEND AN ACK WHILE THE TX CHANNEL IS BUSY","ACK_SEND_CODE","","");
						
					/* create an ACK MAC frame (MPDU) */
					ack_MPDU = op_pk_create_fmt ("wpan_ack_MPDU_format");
						
					op_pk_nfd_set (ack_MPDU, "Frame Type", ACK_FRAME_TYPE);
					op_pk_nfd_set (ack_MPDU, "Sequence Number", ack_sequence_number);
					op_pk_nfd_set (ack_MPDU, "Ack Request", 0);
					
					/* create PHY frame (PPDU) that encapsulates MAC frame (MPDU) */
					frame_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
						
					/* wrap MAC frame MPDU in PHY frame (PPDU) */
					op_pk_nfd_set_pkt (frame_PPDU, "PSDU", ack_MPDU); 
					op_pk_nfd_set (frame_PPDU, "Frame Length", ((double) op_pk_total_size_get(ack_MPDU))/8); //[bytes]						
					
					wpan_battery_update_tx ((double)op_pk_total_size_get(frame_PPDU));
					
					op_pk_send (frame_PPDU, STRM_FROM_MAC_TO_RADIO);
					
					break;
				};	/*end of ACK_SEND_CODE */
				
				case ACK_SUCCESS_CODE:
				{
					if (GTS.GTS_ACTIVE) {
						if (enable_log) {
							fprintf(log,"t=%f  !!!!!!!!! ACK RECEIVED WITH SUCCESS AFTER %d retries  - TRY TO SEND NEXT PACKET !!!!!!!!!  \n\n",op_sim_time(), GTS.retries_nbr);
							printf(" [Node %s] t=%f  !!!!!!!!! ACK RECEIVED WITH SUCCESS AFTER %d retries  - TRY TO SEND NEXT PACKET !!!!!!!!!\n\n",my_attributes.name, op_sim_time(), GTS.retries_nbr);
						}
						
						GTS.retries_nbr = 0;
						
						op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE);
					
					} else {
						if (enable_log) {
							fprintf(log,"t=%f !!!!!!!!! ACK RECEIVED WITH SUCCESS AFTER %d retries - TRY TO SEND NEXT PACKET !!!!!!!!! \n\n",op_sim_time(), csma.retries_nbr);
							printf(" [Node %s] t=%f !!!!!!!!! ACK RECEIVED WITH SUCCESS AFTER %d retries - TRY TO SEND NEXT PACKET !!!!!!!!! \n\n",my_attributes.name, op_sim_time(), csma.retries_nbr);
						}
					
						op_stat_write(statistic_vector.retransmission_attempts, csma.retries_nbr);
						csma.retries_nbr = 0;
					
						op_stat_write(statistic_vector.dropped_ack_packets, 0.0);
						op_stat_write(statistic_vector.dropped_packets, 0.0);
						op_stat_write(statistic_vector.success_ack_packets, 1.0);
					
						op_stat_write(statistic_global_vector.dropped_ack_packets, 0.0);
						op_stat_write(statistic_global_vector.dropped_packets, 0.0);
						op_stat_write(statistic_global_vector.success_ack_packets, 1.0);
					
						op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);						
					}					
					
					break;		
				};	/*end of ACK_SUCCESS_CODE */
			
				case ACK_FAILURE_CODE:	/* ACK was not received in time*/
				{
					if (GTS.GTS_ACTIVE) { // GTS						
						if (GTS.retries_nbr < aMaxFrameRetries) {
							if (enable_log) {
								fprintf(log,"t=%f  -> ACK RECEPTION FAILURE - TRY TO RETRANSMIT  (number of retries = %d) \n\n", op_sim_time(), GTS.retries_nbr);
								printf(" [Node %s] t=%f  -> ACK RECEPTION FAILURE - TRY TO RETRANSMIT  (number of retries = %d) <-  \n\n", my_attributes.name, op_sim_time(), GTS.retries_nbr);
							}
							op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE); // try to send the same packet							
						} else { 
							/* GTS.retries_nbr >= aMaxFrameRetries */
							GTS.retries_nbr = GTS.retries_nbr-1;	//GTS.retries_nbr is again incremented inside the FAILURE_CODE case
							
							if (enable_log) {
								fprintf(log,"t=%f  -> ACK RECEPTION FAILURE (number of retries = %d = aMaxFrameRetries) <- \n\n", op_sim_time(), GTS.retries_nbr);							
								printf(" [Node %s] t=%f  -> ACK RECEPTION FAILURE (number of retries = %d = aMaxFrameRetries) <- \n\n", my_attributes.name, op_sim_time(), GTS.retries_nbr);							
								fprintf(log," !!!!!!!!! DROP PACKET AT THE HEAD !!!!!!!!! \n\n");
								printf(" !!!!!!!!! DROP PACKET AT THE HEAD OF QUEUE!!!!!!!!! \n\n");
							}
							
							frame_MPDU = op_subq_pk_remove(SUBQ_GTS,OPC_QPOS_HEAD); // remove MAC frame (MPDU) at the head of GTS subqueue
							op_pk_destroy(frame_MPDU);	// drop the frame					
	
							GTS.retries_nbr = 0;
							
							op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE);	// try to send next packet 						
						}
						
						GTS.retries_nbr = GTS.retries_nbr+1;
					
					} else {	// CAP						
						if (csma.retries_nbr < aMaxFrameRetries) {
							if (enable_log) {
								fprintf(log,"t=%f  -> ACK RECEPTION FAILURE - RETURN TO BACKOFF (number of retries = %d) \n\n", op_sim_time(), csma.retries_nbr);
								printf(" [Node %s] t=%f  -> ACK RECEPTION FAILURE - RETURN TO BACKOFF  (number of retries = %d) <-  \n\n", my_attributes.name, op_sim_time(), csma.retries_nbr);
							}
						
							op_stat_write(statistic_vector.dropped_ack_packets, 0.0);
							op_stat_write(statistic_vector.dropped_packets, 0.0);
								
							op_stat_write(statistic_global_vector.dropped_ack_packets, 0.0);
							op_stat_write(statistic_global_vector.dropped_packets, 0.0);
						
							csma.NB = csma.NB+1;
							csma.CW = 2;
							csma.BE = min_int(csma.BE+1,aMaxBE);
						
							if (csma.NB <= csma.MAX_CSMA_BACKOFF){
								/*redo another backoff */
								wpan_backoff_delay_set();
								op_intrpt_schedule_self (op_sim_time(), RETURN_TO_BACKOFF_CODE);
							} else { 
								/*report a transmission failure */
								if (enable_log) {
									fprintf(log,"t=%f  -> ACK TRANSMISSION FAILURE - PACKET CAN NOT BE DISPATCHED !!! \n\n", op_sim_time());
									printf(" [Node %s] t=%f  -> ACK TRANSMISSION FAILURE - PACKET CAN NOT BE DISPATCHED !!! <- \n\n", my_attributes.name, op_sim_time());
								}
							
								op_stat_write(statistic_vector.failure, 1.0);
								op_stat_write(statistic_vector.success, 0.0);								
							
								op_intrpt_schedule_self (op_sim_time(), FAILURE_CODE); 
							}						
						} else {	
							/*csma.retries_nbr >= aMaxFrameRetries*/
													
							if (enable_log) {
								fprintf(log,"t=%f  -> ACK RECEPTION FAILURE (number of retries = %d = aMaxFrameRetries) <- \n\n", op_sim_time(), csma.retries_nbr);							
								printf(" [Node %s] t=%f  -> ACK RECEPTION FAILURE (number of retries = %d = aMaxFrameRetries) <- \n\n", my_attributes.name, op_sim_time(), csma.retries_nbr);							
							}
						
							op_stat_write(statistic_vector.dropped_ack_packets, 1.0);
							op_stat_write(statistic_global_vector.dropped_ack_packets, 1.0);
						
							op_intrpt_schedule_self (op_sim_time(), FAILURE_CODE); 
						}
						
						csma.retries_nbr = csma.retries_nbr+1;
					
						op_stat_write(statistic_vector.success_ack_packets, 0.0);
						op_stat_write(statistic_global_vector.success_ack_packets, 0.0);
					}
					
					mac_attributes.wait_ack = OPC_FALSE;
					
					break;				
		
				};	/*end of ACK_FAILURE_CODE */
			
				case SUCCESS_CODE :	// packet was succesffully sent to the network: |PACKET| or |PACKET|+|IFS|
				{
					if (enable_log) { 
						fprintf(log,"t=%f  -> !!!!!!!!! PACKET TRANSMISSION FINISHED WITH SUCCESS !!!!!!!!!  \n\n",op_sim_time());
						printf(" [Node %s] t=%f  !!!!!!!!! PACKET TRANSMISSION FINISHED WITH SUCCESS !!!!!!!!! \n\n",my_attributes.name, op_sim_time());
					}
					
					if (GTS.GTS_ACTIVE) {					
						if (mac_attributes.wait_ack == OPC_FALSE) {
							is_GTS_tx_time_active = OPC_FALSE; // end of the GTS packet transmission cycle: |PACKET|+|IFS|
							op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE);	// try to send next packet 								
						}
					} else {					
						op_stat_write(statistic_vector.dropped_packets, 0.0);
						op_stat_write(statistic_global_vector.dropped_packets, 0.0);
					
						if (mac_attributes.wait_ack == OPC_FALSE)
							op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);	// try to send next packet 
					}
					
					break;
				};	/*end of SUCCESS_CODE */
			
				case FAILURE_CODE: 
				{	
					if (enable_log) {
						fprintf(log,"t=%f  -> TRANSMISSION FAILURE    \n\n",op_sim_time());
						printf(" [Node %s] t=%f  -> TRANSMISSION FAILURE \n\n",my_attributes.name,op_sim_time());
					}
				
					if (csma.retries_nbr < aMaxFrameRetries) {
						if (enable_log) {
							fprintf(log,"t=%f  -> TRANSMISSION FAILURE - TRY TO RETRANSMIT  (number of retries = %d) \n\n", op_sim_time(), csma.retries_nbr);
							printf("\n [Node %s] t=%f  -> TRANSMISSION FAILURE - TRY TO RETRANSMIT  (number of retries = %d) <- \n\n", my_attributes.name, op_sim_time(), csma.retries_nbr);
						}
						op_stat_write(statistic_vector.dropped_packets, 0.0);
						op_stat_write(statistic_global_vector.dropped_packets, 0.0);						
						
						op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);	// try to send the same packet once more
						
					} else { /* csma.retries_nbr >= aMaxFrameRetries */
						if (enable_log) {
							fprintf(log,"t=%f  -> TRANSMISSION FAILURE (number of retries = %d = aMaxFrameRetries)  <- \n", op_sim_time(), csma.retries_nbr);
							printf(" [Node %s] t=%f  -> TRANSMISSION FAILURE (number of retries = %d = aMaxFrameRetries) <- \n",my_attributes.name, op_sim_time(), csma.retries_nbr);
							fprintf(log," !!!!!!!!! DROP PACKET AT THE HEAD !!!!!!!!! \n\n");
							printf(" !!!!!!!!! DROP PACKET AT THE HEAD OF QUEUE!!!!!!!!! \n\n");
						}
						
						op_stat_write(statistic_vector.dropped_packets, 1.0);
						op_stat_write(statistic_global_vector.dropped_packets, 1.0);
						
						frame_MPDU = op_subq_pk_remove(SUBQ_ZERO,OPC_QPOS_HEAD); // remove MAC frame (MPDU) at the head of subqueue
						//op_pk_nfd_get(frame_MPDU, "Ack Request", &ack_request);
						op_pk_destroy(frame_MPDU);						
	
						op_stat_write(statistic_vector.retransmission_attempts, csma.retries_nbr);
						csma.retries_nbr = 0;
							
						op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);	// try to send next packet					
					}
					
					break;
				}; /*end of FAILURE_CODE */
				
				case START_OF_GTS_USE:	/* try to allocate appropriate GTS slots */ 				
				{
					if (my_attributes.is_GTS_Permit) {
						wpan_gts_allocation_request ();	
						
						if (enable_log) {
							fprintf (log,"t=%f  ->  START OF THE USING OF THE GTS (attempt to an allocation) <-   \n\n", op_sim_time());
							printf (" [Node %s] t=%f  ->  START OF THE USING OF THE GTS (attempt to an allocation) <-  \n\n",my_attributes.name, op_sim_time());
						}
					} else if (my_attributes.PANcoordinator_mac_address == -1) { // wait for first beacon and then check GTS permit again
						waiting_for_first_beacon = OPC_TRUE;
						
						if (enable_log) {
							fprintf (log,"t=%f  ->  Issue of GTS request was postponed until the first beacon reception  <-   \n\n", op_sim_time());
							printf (" [Node %s] t=%f  ->  Issue of GTS request was postponed until the first beacon reception <-  \n\n",my_attributes.name, op_sim_time());
						}
					} else {
						if (enable_log) {
							fprintf (log,"t=%f  ->  PAN COORDINATOR DOES NOT ACCEPT GTS REQUEST (GTS Permit attribute = FALSE). GTS WILL NOT BE USED. <-   \n\n", op_sim_time());
							printf (" [Node %s] t=%f  ->  PAN COORDINATOR DOES NOT ACCEPT GTS REQUEST (GTS Permit attribute = FALSE). GTS WILL NOT BE USED. <-  \n\n",my_attributes.name, op_sim_time());
						}
					}					
					
					break;						
				};	/* end of START_OF_GTS_USE */
				
				case STOP_OF_GTS_USE: 
				{
					if (my_attributes.is_GTS_Permit) {
						wpan_gts_deallocation_request ();
					
						/* stop generate GTS Traffic */
						op_intrpt_schedule_remote (op_sim_time(), STOP_GTS_TRAFFIC, my_attributes.gts_traffic_source);	
					
						if (enable_log) {
							fprintf (log,"t=%f  -> STOP OF THE USING OF THE GTS (deallocation) <-   \n\n", op_sim_time());
							printf (" [Node %s] t=%f  -> STOP OF THE USING OF THE GTS (deallocation) <-  \n\n",my_attributes.name, op_sim_time());
						}
					}
					
					break;
				};	/* end of STOP_OF_GTS_USE */
				
				case START_OF_GTS_PERIOD:
				{					
					if (enable_log) {
						fprintf (log,"t=%f  -> START of the GTS data period [length: %d slots (%f msec), Direction: %d]. <-   \n\n", op_sim_time(), GTS.length, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE), GTS.direction);
						printf (" [Node %s] t=%f  -> START of the GTS data period  [length: %d slots (%f msec), Direction: %d].  <-  \n\n",my_attributes.name, op_sim_time(), GTS.length, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE), GTS.direction);
					}
					
					GTS.GTS_ACTIVE = OPC_TRUE;
					sent_gts_bits = 0;
					gts_statistics.gts_periods_count++;
					is_GTS_tx_time_active = OPC_FALSE;
					
					if (GTS.direction == GTS_DIRECTION_TRANSMIT)
						op_intrpt_schedule_self (op_sim_time(), TRY_GTS_PACKET_TRANSMISSION_CODE);			
				
					break;
				};	/* end of START_OF_GTS_PERIOD */
				
				case END_OF_GTS_PERIOD:
				{
					GTS.GTS_ACTIVE = OPC_FALSE;
					
					if (enable_log) {
						fprintf (log,"t=%f  -> END of the GTS data period. <-  \n", op_sim_time());
						printf (" [Node %s] t=%f  -> END of the GTS data period. <-- \n",my_attributes.name, op_sim_time());
					}
					
					if (GTS.direction == GTS_DIRECTION_TRANSMIT) {		
						gts_statistics.band_wast_sum = gts_statistics.band_wast_sum + (1 - ((double) sent_gts_bits)/(GTS.length*SF.slot_duration*Symbol2Bits));

						op_stat_write (gts_statistic_vector.wasted_bandwidth_pc, (1 - ((double) sent_gts_bits)/(GTS.length*SF.slot_duration*Symbol2Bits))); 
						op_stat_write (gts_statistic_vector.throughput_pc, ((double) sent_gts_bits)/(GTS.length*SF.slot_duration*Symbol2Bits));
						
						if (enable_log) {
							fprintf (log,"\t + GTS period length: %d bits (%f msec), sent bits (PPDU): %d, wasted bandwidth: %f %%.\n\n", GTS.length*SF.slot_duration*Symbol2Bits, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE), sent_gts_bits, (1 - ((double) sent_gts_bits)/(GTS.length*SF.slot_duration*Symbol2Bits))*100);
							printf ("\t + GTS period length: %d bits (%f msec), sent bits (PPDU): %d, wasted bandwidth: %f %%.\n\n", GTS.length*SF.slot_duration*Symbol2Bits, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE), sent_gts_bits, (1 - ((double) sent_gts_bits)/(GTS.length*SF.slot_duration*Symbol2Bits))*100);
						}
					}

					break;
				};	/* end of END_OF_GTS_PERIOD */
				
				case TRY_GTS_PACKET_TRANSMISSION_CODE:
				{	
					if (!op_subq_empty (SUBQ_GTS) && start_GTS_transmission) {
						/* obtain the pointer to packet stored in the GTS queue */
						frame_MPDU = op_subq_pk_access (SUBQ_GTS, OPC_QPOS_HEAD);						
						op_pk_nfd_get(frame_MPDU, "Sequence Number", &seq_num);
						op_pk_nfd_get(frame_MPDU, "Ack Request", &ack_request);
						
						/* check at the beginning, if the channel is busy */						
						if (op_stat_local_read (TX_BUSY_STAT) == 1.0)
							op_sim_end("ERROR : TRY TO SEND GTS PACKET WHILE THE TX CHANNEL IS BUSY","TRY_GTS_PACKET_TRANSMISSION_CODE","","");
						
						if (wpan_gts_check_time (frame_MPDU)) {
							if (ack_request == 0) { // packet without ACK
						
								/* remove MAC frame (MPDU) at the head of subqueue */
								frame_MPDU_to_send = op_subq_pk_remove (SUBQ_GTS, OPC_QPOS_HEAD); 						
						
								if (enable_log) {
									fprintf(log,"t=%f  ----------- START GTS TX [SEQ = %d, no ACK] ............ \n\n", op_sim_time(), seq_num);
									printf(" [Node %s] t=%f  ----------- START GTS TX [SEQ = %d, no ACK] ............ \n\n", my_attributes.name, op_sim_time(), seq_num);
								}

								mac_attributes.wait_ack = OPC_FALSE;	
								
								/* create PHY frame (PPDU) that encapsulates MAC frame (MPDU) */
								frame_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
								
								/* wrap MAC frame MPDU in PHY frame (PPDU) */
								op_pk_nfd_set_pkt (frame_PPDU, "PSDU", frame_MPDU_to_send); 
								op_pk_nfd_set (frame_PPDU, "Frame Length", ((double) op_pk_total_size_get(frame_MPDU_to_send))/8); //[bytes]	
							
								/* |PACKET|+|IFS| */
								tx_time = Symbols2Sec(Bits2Symbols((int) op_pk_total_size_get(frame_PPDU)), WPAN_DATA_RATE) + Symbols2Sec(wpan_ifs_symbol_get(frame_MPDU_to_send), WPAN_DATA_RATE); 
							
								op_intrpt_schedule_self (op_sim_time()+tx_time, SUCCESS_CODE);
					
								wpan_battery_update_tx((double)op_pk_total_size_get(frame_PPDU));
								
								op_pk_send (frame_PPDU, STRM_FROM_MAC_TO_RADIO);	
								
								is_GTS_tx_time_active = OPC_TRUE; // TRUE during the packet TX time: |PACKET|+|IFS|
								
								op_stat_write (gts_statistic_vector.sent_frames, (double)(op_pk_total_size_get(frame_PPDU)));
								op_stat_write (gts_statistic_vector.sent_framesG, (double)(op_pk_total_size_get(frame_PPDU)));								
								op_stat_write (gts_statistic_vector.frame_delay, (op_sim_time() - op_pk_creation_time_get(frame_MPDU_to_send)));								
								op_stat_write (statistic_global_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
								op_stat_write (statistic_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));								
								
								gts_statistics.frame_delay_sum = gts_statistics.frame_delay_sum + (op_sim_time() - op_pk_creation_time_get(frame_MPDU_to_send));
								gts_statistics.frame_delay_max = max_double (gts_statistics.frame_delay_max, (op_sim_time() - op_pk_creation_time_get(frame_MPDU_to_send)));
								gts_statistics.frame_delay_min = min_double (gts_statistics.frame_delay_min, (op_sim_time() - op_pk_creation_time_get(frame_MPDU_to_send)));	
								gts_statistics.sent_frames++;
								gts_statistics.sent_bits = gts_statistics.sent_bits + op_pk_total_size_get(frame_PPDU);
								
								sent_gts_bits = sent_gts_bits + op_pk_total_size_get(frame_PPDU);						
							} else {	// packet with ACK
						
								mac_attributes.wait_ack = OPC_TRUE;
								
								frame_MPDU_copy = op_pk_copy(frame_MPDU);
								
								/* put in memory the requested ack seq number */
								op_pk_nfd_get (frame_MPDU_copy, "Sequence Number", &mac_attributes.wait_ack_seq_num);
						
								/* create PHY frame (PPDU) that encapsulates MAC frame (MPDU) */
								frame_PPDU = op_pk_create_fmt("wpan_frame_PPDU_format");
						
								/* wrap MAC frame (MPDU) in PHY frame (PPDU) */
								op_pk_nfd_set_pkt (frame_PPDU, "PSDU", frame_MPDU_copy); 
								op_pk_nfd_set (frame_PPDU, "Frame Length", ((double) op_pk_total_size_get(frame_MPDU_copy))/8); //[bytes]	
						
								/* |PACKET| */
								tx_time = Symbols2Sec(Bits2Symbols((int) op_pk_total_size_get(frame_PPDU)), WPAN_DATA_RATE);
						
								op_intrpt_schedule_self (op_sim_time()+tx_time, SUCCESS_CODE);
								op_intrpt_schedule_self (op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE), WAITING_ACK_END_CODE);
						
								if (enable_log) {
									fprintf(log,"t=%f   ----------- START GTS TX [SEQ = %d, with ACK expiring at %f] ............ \n\n", op_sim_time(), seq_num, op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE));
									printf(" [Node %s] t=%f  ----------- START GTS TX [SEQ = %d, with ACK expiring at %f] ............ \n\n", my_attributes.name, op_sim_time(), seq_num, op_sim_time()+tx_time+Symbols2Sec(macAckWaitDuration, WPAN_DATA_RATE));
								}							
						
								wpan_battery_update_tx((double)op_pk_total_size_get(frame_PPDU));								
						
								op_pk_send (frame_PPDU, STRM_FROM_MAC_TO_RADIO);
								
								//is_GTS_tx_time_active = OPC_TRUE;	//TRUE during the packet TX time: |PACKET|
								
								gts_pkt_delay = op_sim_time() - op_pk_creation_time_get(frame_MPDU);					
								
								op_stat_write (gts_statistic_vector.sent_frames, (double)(op_pk_total_size_get(frame_PPDU)));
								op_stat_write (gts_statistic_vector.sent_framesG, (double)(op_pk_total_size_get(frame_PPDU)));								
								op_stat_write (statistic_global_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
								op_stat_write (statistic_vector.sent_pkt, (double)(op_pk_total_size_get(frame_PPDU)));
								
								gts_statistics.sent_frames++;
								gts_statistics.sent_bits = gts_statistics.sent_bits + op_pk_total_size_get(frame_PPDU);
								
								sent_gts_bits = sent_gts_bits + op_pk_total_size_get(frame_PPDU);
							}						
						} else {
							if (enable_log) {
								fprintf (log,"t=%f  -> NOT ENOUGH TIME IN THE GTS PERIOD - DEFER FRAME TRANSMISSION UNTIL NEXT GTS. \n", op_sim_time());
								fprintf (log,"\t + GTS time = %f sec - GTS Subqueue still contains %.0f frames and %.0f bits. \n\n",  (SF.BI_Boundary + Symbols2Sec((GTS.start_slot*SF.slot_duration), WPAN_DATA_RATE) + Symbols2Sec((GTS.length*SF.slot_duration), WPAN_DATA_RATE))-op_sim_time(), op_subq_stat (SUBQ_GTS, OPC_QSTAT_PKSIZE), op_subq_stat (SUBQ_GTS, OPC_QSTAT_BITSIZE));
								printf (" [Node %s] t=%f  -> NOT ENOUGH TIME IN THE GTS PERIOD - DEFER FRAME TRANSMISSION UNTIL NEXT GTS. \n", my_attributes.name, op_sim_time());
								printf ("\t + GTS time = %f sec - GTS Subqueue still contains %.0f frames and %.0f bits. \n\n",  (SF.BI_Boundary + Symbols2Sec((GTS.start_slot*SF.slot_duration), WPAN_DATA_RATE) + Symbols2Sec((GTS.length*SF.slot_duration), WPAN_DATA_RATE))-op_sim_time(), op_subq_stat (SUBQ_GTS, OPC_QSTAT_PKSIZE), op_subq_stat (SUBQ_GTS, OPC_QSTAT_BITSIZE));
							}							
						}						
					} else {
						if (enable_log) {
							fprintf(log,"t=%f  -> The GTS subqueue is EMPTY. Waiting for the upcomming GTS frame. <- \n\n", op_sim_time());
							printf(" [Node %s] t=%f  -> The GTS subqueue is EMPTY. Waiting for the upcomming GTS frame. <- \n\n", my_attributes.name, op_sim_time());
						}					
					}
				
					break;
				};	/* end of TRY_GTS_PACKET_TRANSMISSION_CODE */
				
				default:
				{
				};	
				
			} /*end of switch (op_intrpt_code())*/ 
			
			break;
		};/*end of OPC_INTRPT_SELF */
		
		case OPC_INTRPT_ENDSIM:
		{
			if (enable_log) {
				fprintf (log, "t=%f  ***********   GAME OVER END - OF SIMULATION  ********************  \n\n",op_sim_time());
				printf (" [Node %s] t=%f  ***********   GAME OVER - END OF SIMULATION  *******************\n\n", my_attributes.name, op_sim_time());
				
				if (gts_statistics.gts_periods_count > 0) {
					fprintf (log, "|------------------------------ GTS STATISTICS -------------------------------|\n");
					fprintf (log, " [GTS Buffer size = %d bits, GTS length = %d slots = %.3f msec] \n", gts_queue_capacity, GTS.length, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE));
					fprintf (log, " Frames generated during the simulation  	= %.0f = %.3f Kbits (MPDU) \n", gts_statistics.generated_frames, gts_statistics.generated_bits*0.001);
					fprintf (log, " Frames dispatched during the simulation     = %.0f = %.3f Kbits (PPDU) \n", gts_statistics.sent_frames, gts_statistics.sent_bits*0.001);
					fprintf (log, " Dropped frames (overfull buffer)           	= %.0f = %.3f Kbits -> %.3f %% (MPDU) \n", gts_statistics.dropped_frames, gts_statistics.dropped_bits*0.001, (gts_statistics.dropped_frames/gts_statistics.generated_frames)*100);
					fprintf (log, " Number of the GTS periods during the simulation = %.0f \n", gts_statistics.gts_periods_count);
					fprintf (log, " Throughtput: \n");
					fprintf (log, "   Average wasted bandwidth = %f %% \n", (gts_statistics.band_wast_sum/gts_statistics.gts_periods_count)*100);
					fprintf (log, "   Average throughput = %f %% \n", (1-gts_statistics.band_wast_sum/gts_statistics.gts_periods_count)*100);
					
				
					if (gts_statistics.sent_frames > 0) {
						fprintf (log, " GTS packet delay (from generation to transmition):\n");
						fprintf (log, "   max = %.3f sec \n", gts_statistics.frame_delay_max);
						fprintf (log, "   min = %.3f sec \n", gts_statistics.frame_delay_min);
						fprintf (log, "   average = %.3f sec \n", gts_statistics.frame_delay_sum/gts_statistics.sent_frames);
					}
					
					fprintf (log, "|-----------------------------------------------------------------------------|\n\n");
				}				
				
				if (gts_statistics.gts_periods_count > 0) {
					printf ("|------------------------------ GTS STATISTICS -------------------------------|\n");
					printf (" [Node %s : GTS Buffer size = %d bits, GTS length = %d slots = %.3f msec]\n", my_attributes.name, gts_queue_capacity, GTS.length, Symbols2ms(GTS.length*SF.slot_duration, WPAN_DATA_RATE));
					printf (" Frames generated during the simulation 		= %.0f = %.3f Kbits (MPDU) \n", gts_statistics.generated_frames, gts_statistics.generated_bits*0.001);
					printf (" Frames dispatched during the simulation      	= %.0f = %.3f Kbits (MPDU) \n", gts_statistics.sent_frames, gts_statistics.sent_bits*0.001);
					printf (" Dropped frames (overfull buffer)          	= %.0f = %.3f Kbits -> %.3f %% (PPDU) \n", gts_statistics.dropped_frames, gts_statistics.dropped_bits*0.001, (gts_statistics.dropped_frames/gts_statistics.generated_frames)*100);
					printf (" Number of the GTS periods during the simulation = %.0f \n", gts_statistics.gts_periods_count);
					printf (" Throughtput: \n");
					printf ("   Average wasted bandwidth = %.3f %% \n", (gts_statistics.band_wast_sum/gts_statistics.gts_periods_count)*100);
					printf ("   Average throughput = %.3f %% \n", (1-gts_statistics.band_wast_sum/gts_statistics.gts_periods_count)*100);
					
				
					if (gts_statistics.sent_frames > 0) {
						printf (" GTS packet delay (from generation to transmition):\n");
						printf ("   max = %.3f sec \n", gts_statistics.frame_delay_max);
						printf ("   min = %.3f sec \n", gts_statistics.frame_delay_min);
						printf ("   average = %.3f sec \n", gts_statistics.frame_delay_sum/gts_statistics.sent_frames);
					}
					
					printf ("|-----------------------------------------------------------------------------|\n\n");
				}				
				
				fclose(log);
			}

			break;
		};	/*end of OPC_INTRPT_ENDSIM */
		
		case OPC_INTRPT_STAT: // statistic interrupt from PHY layer
		{
			switch (op_intrpt_stat()) {	/*begin switch (op_intrpt_stat())*/ 
				
				case RX_BUSY_STAT :	/* Case of the end of the BUSY RECEIVER STATISTIC */
				{
					/* if during the CCA the channel was busy for a while, then csma.CCA_CHANNEL_IDLE = OPC_FALSE*/
					if (op_stat_local_read(RX_BUSY_STAT) == 1.0)
						csma.CCA_CHANNEL_IDLE = OPC_FALSE;
				
					/*Try to send a packet if any*/
					if (op_stat_local_read (TX_BUSY_STAT) == 0.0)
						op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);
					
					break;
				}
				
				case TX_BUSY_STAT :
				{
					if (op_stat_local_read (TX_BUSY_STAT) == 0.0)
						op_intrpt_schedule_self (op_sim_time(), TRY_PACKET_TRANSMISSION_CODE);
					
					break;
				}
				
				case RX_COLLISION_STAT :
				{
					if (enable_log){
						fprintf(log,"t=%f  -> $$$$$ COLLISION $$$$$$$  \n\n",op_sim_time());
						printf(" [Node %s] t=%f  -> COLLISION TIME  \n",my_attributes.name, op_sim_time());
					}
					
					break;
				}
			}/*end switch (op_intrpt_stat())*/
			
			break;
		};/*end of OPC_INTRPT_STAT */
		
		default :
		{
		};
		
	} /*end switch (op_intrpt_type())*/
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_init
 *
 * Description:	Initializes the backoff process
 *
 *    			NB = 0   the number of times the CSMA/CA was required to backoff while
 *              		attempting to access the current channel. this value is initialized
 *              		to zero before each new transmission attempts
 *     
 *    			CW = 2   in the contention window length which defines the number of backoff 
 *             			periods that need to be clear of channel activity before starting transmission
 *              		CW initialized to 2 before each transmission attempt and reset to 2 each 
 *              		time the channel is assessed to be busy. 
 *     
 *     			BE = min(2,macMinBe)   is the backoff exponent, which is related to how many backoff period 
 *                           		a device must wait before attempting to assess the channel activity.
 *        
 *             
 * No parameters 
 *--------------------------------------------------------------------------------*/
static void wpan_backoff_init() {	

	/* Stack tracing enrty point */
	FIN(wpan_backoff_init);

	if (enable_log) {
		fprintf(log," - BACKOFF INIT t=%f \n", op_sim_time());
		printf(" [Node %s] t=%f  - BACKOFF INIT  \n", my_attributes.name, op_sim_time());
	}

	csma.NB = 0;
	csma.CW = 2;
	csma.BE = csma.macMinBE;
	if (mac_attributes.Battery_Life_Extension == OPC_TRUE)
		csma.BE = min_int(2,csma.macMinBE);
	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_update
 *
 * Description: update the backoff process when the channel is busy
 *             
 * No parameters
 *--------------------------------------------------------------------------------*/
static void wpan_backoff_update() {	

	/* Stack tracing enrty point */
	FIN(wpan_backoff_update);
	
	if (enable_log) {
		fprintf(log,"t=%f  -> BACKOFF UPDATE - CHANNEL IS BUSY  \n\n", op_sim_time());	
		printf(" [Node %s] t=%f  -> BACKOFF UPDATE - CHANNEL IS BUSY  \n", my_attributes.name, op_sim_time());
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_delay_set()
 *
 * Description:	set the backoff timer to a random value
 *             
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_backoff_delay_set() {	
	
	int backoff_unit;
	int backoff_max;
	double backoff_time;
	double end_cap_time;
	double backoff_expiration_time;
	double remaining_cap_time;
	double cap_length;
	
	/* Stack tracing enrty point */
	FIN(wpan_backoff_delay_set);
	
	backoff_max = (int) (01<<csma.BE) - 1;      //(2^BE-1)
	backoff_unit = floor (op_dist_uniform (backoff_max+1)); // Randon number of backoffunits
	op_stat_write(statistic_vector.backoff_units, backoff_unit);
	
	backoff_time = ((double) backoff_unit * Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE));
	op_stat_write(statistic_vector.backoff_delay, backoff_time);
	
	/*check if the backoff time will exceed the remaining time in the CAP */	
	end_cap_time = SF.BI_Boundary + Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE);
	backoff_expiration_time = wpan_backoff_period_boundary_get() + backoff_time;	
	remaining_cap_time = end_cap_time - wpan_backoff_period_boundary_get();	
	cap_length = (SF.Final_CAP_Slot+1)*Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE);		
	
	/* the backoff is accepted if it expires at most aUnitBackoffPeriod before the end of CAP */	
	if (compare_doubles((remaining_cap_time - Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE)), backoff_time) >=0) {	// THERE IS A PROBLEM WITH EQUALITY IN DOUBLE
	
		if (enable_log) {
			fprintf(log,"t=%f  -> ENTERS BACKOFF  - BE = %d; RANDOM BACKOFF = % d; EXPIRATION AT %f  \n\n", op_sim_time(), csma.BE,backoff_unit,backoff_expiration_time );
			printf(" [Node %s] t=%f  -> ENTERS BACKOFF  - BE = %d; RANDOM BACKOFF = % d; EXPIRATION AT %f  \n\n", my_attributes.name, op_sim_time(), csma.BE,backoff_unit,backoff_expiration_time );
		}

		SF.RESUME_BACKOFF_TIMER = OPC_FALSE;
		SF.backoff_timer = -1;
		//op_intrpt_priority_set (OPC_INTRPT_SELF, BACKOFF_EXPIRATION_CODE, 15);
		op_intrpt_schedule_self (backoff_expiration_time, BACKOFF_EXPIRATION_CODE);			
	}
	else {	/* if the remaining period of the CAP is lower than the backoff period the timer must wake up at the CAP of the next superframe */
		
		if (enable_log) {
			fprintf(log,"t=%f  -> BACKOFF PAUSED UNTIL THE CAP OF THE NEXT SUPERFRAME  \n\n", op_sim_time());	
			printf(" [Node %s] t=%f  -> BACKOFF PAUSED UNTIL THE CAP OF THE NEXT SUPERFRAME  \n", my_attributes.name, op_sim_time());
		}

		SF.RESUME_BACKOFF_TIMER = OPC_TRUE;
		SF.backoff_timer = backoff_time - remaining_cap_time;
		backoff_expiration_time = -1;
		op_stat_write (statistic_vector.deferred_cca_backoff, SF.RESUME_BACKOFF_TIMER);
	}		
	
	if (enable_log) {	
		printf ("-------------------------- BACKOFF -----------------------------------\n");
		printf (" [Node %s] ENTERS BACKOFF STATUT AT %f\n", my_attributes.name, op_sim_time());
		printf ("  Beacon Boundary = %f\n", SF.BI_Boundary);
		printf ("  NB = %d (macMaxCSMABackoffs = %d)\n", csma.NB, csma.MAX_CSMA_BACKOFF);
		printf ("  CW = %d\n", csma.CW);
		printf ("  BE = %d\n", csma.BE);
		printf ("  2^BE-1 = %d\n", backoff_max);
		printf ("  Random Backoff units = %d\n", backoff_unit);
		printf ("    + Random Backoff time  = %f sec \n", backoff_time);
		printf ("    + Remaining CAP Length = %f sec \n", remaining_cap_time);
		printf ("    + RESUME BACKOFF TIME  = %f sec \n", SF.backoff_timer);
		printf ("  Total CAP Length = %f sec\n", cap_length);
		printf ("  Beacon Interval = %f sec = %d Symbols\n", Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI);
		printf ("  Slot Duration = %f sec = %d Symbols \n", Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE), SF.slot_duration);
		printf ("  Backoff Boundary Index = %d\n", wpan_backoff_period_index_get());
		printf ("  Current Time Slot = %d\n", wpan_current_time_slot_get());
		printf ("  \n  CAP STATUT = %s \n", boolean2string(SF.CAP_ACTIVE));
		printf ("  CFP STATUT = %s \n", boolean2string(SF.CFP_ACTIVE));
		printf ("  SLEEP STATUT = %s \n", boolean2string(SF.SLEEP));
		printf ("  Backoff Boundary = %f sec \n", wpan_backoff_period_boundary_get());
		printf ("  End CAP Time     = %f sec \n", end_cap_time);
		printf ("  Difference       = %f sec \n", end_cap_time-wpan_backoff_period_boundary_get());
		printf ("  BackOff Expiration Time  = %f sec\n", backoff_expiration_time);
		printf ("----------------------------------------------------------------------------\n\n");
	
		fprintf (log, "-------------------------- BACKOFF -----------------------------------\n");
		fprintf (log, "ENTERS BACKOFF STATUT AT %f\n", op_sim_time());
		fprintf (log, "  Beacon Boundary = %f\n", SF.BI_Boundary);
		fprintf (log, "  NB = %d (macMaxCSMABackoffs = %d)\n", csma.NB, csma.MAX_CSMA_BACKOFF);
		fprintf (log, "  CW = %d\n", csma.CW);
		fprintf (log, "  BE = %d\n", csma.BE);
		fprintf (log, "  2^BE-1 = %d\n", backoff_max);
		fprintf (log, "  Random Backoff units = %d\n", backoff_unit);
		fprintf (log, "    + Random Backoff time  = %f sec \n", backoff_time);
		fprintf (log, "    + Remaining CAP Length = %f sec \n", remaining_cap_time);
		fprintf (log, "    + RESUME BACKOFF TIME  = %f sec \n", SF.backoff_timer);
		fprintf (log, "  Total CAP Length = %f sec \n", cap_length);
		fprintf (log, "  Beacon Interval = %f sec = %d Symbols\n", Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI);
		fprintf (log, "  Slot Duration = %f sec = %d Symbols \n", Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE), SF.slot_duration);
		fprintf (log, "  Backoff Boundary Index = %d\n", wpan_backoff_period_index_get());
		fprintf (log, "  Current Time Slot = %d\n", wpan_current_time_slot_get());
		fprintf (log, "  \n  CAP STATUT = %s \n", boolean2string(SF.CAP_ACTIVE));
		fprintf (log, "  CFP STATUT = %s \n", boolean2string(SF.CFP_ACTIVE));
		fprintf (log, "  SLEEP STATUT = %s \n", boolean2string(SF.SLEEP));
		fprintf (log, "  Backoff Boundary = %f sec \n", wpan_backoff_period_boundary_get());
		fprintf (log, "  End CAP Time     = %f sec \n", end_cap_time);
		fprintf (log, "  Difference       = %f sec \n", end_cap_time-wpan_backoff_period_boundary_get());
		fprintf (log, "  BackOff Expiration Time  = %f sec \n", backoff_expiration_time);
		fprintf (log, "----------------------------------------------------------------------------\n\n");
	}
	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_period_index_get         BI_Boundary                      
 *
 * Description:	 the next backoff period index,               |-----|-----|-----|--t--|-----|
 *             
 *                                                                                    ^
 * No parameters                                                                      |
 *                                                                           next backoff period index
 *--------------------------------------------------------------------------------*/

static int wpan_backoff_period_index_get() {

	double aUnitBackoffPeriod_Sec;
	int next_backoff_period_index;
	
	/* Stack tracing enrty point */
	FIN(wpan_backoff_period_index_get);
	
	aUnitBackoffPeriod_Sec = Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE);
	next_backoff_period_index = (int)ceil((op_sim_time()-SF.BI_Boundary)/aUnitBackoffPeriod_Sec);
	
	
	return (next_backoff_period_index);
	
	/* Stack tracing exit point */
	FRET(next_backoff_period_index);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_current_time_slot_get
 *
 * Description:	get index of the current time slot (superframe slot)              
                                                                                     
 * No parameters                           
 *--------------------------------------------------------------------------------*/
static int wpan_current_time_slot_get() {

	int current_time_slot_index;
	
	/* Stack tracing enrty point */
	FIN(wpan_current_time_slot_get);
		
	current_time_slot_index = floor ((op_sim_time()-SF.BI_Boundary)/Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE));
		
	return (current_time_slot_index);
	
	/* Stack tracing exit point */
	FRET(current_time_slot_index);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_period_index_get_                              
 *
 * Description:	 the next backoff period index                           
 *                                                                            
 * Input: time                                                                         
 *--------------------------------------------------------------------------------*/
static int wpan_backoff_period_index_get_(double Time) {

	double aUnitBackoffPeriod_Sec;
	int next_backoff_period_index;
	
	/* Stack tracing enrty point */
	FIN(wpan_backoff_period_index_get_);
	
	aUnitBackoffPeriod_Sec = Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE);
	next_backoff_period_index = (int)ceil((Time-SF.BI_Boundary)/aUnitBackoffPeriod_Sec);	
	
	return (next_backoff_period_index);
	
	/* Stack tracing exit point */
	FRET(next_backoff_period_index);
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_period_boundary_get
 *
 * Description:	it is the absolue time that represents the backoff period boundary, 
 *             
 * No parameters  
 *--------------------------------------------------------------------------------*/

static double wpan_backoff_period_boundary_get() {

	double next_backoff_period_boundary;
	double aUnitBackoffPeriod_Sec;
	
	/* Stack tracing enrty point */
	FIN(wpan_backoff_period_boundary_get);
	
	aUnitBackoffPeriod_Sec = Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE);
	next_backoff_period_boundary = SF.BI_Boundary + (wpan_backoff_period_index_get() * aUnitBackoffPeriod_Sec);

	return (next_backoff_period_boundary);
	
	/* Stack tracing exit point */
	FRET(next_backoff_period_boundary);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_backoff_period_boundary_get_
 *
 * Description:	it is the absolue time that represents the backoff period boundary, 
 *             
 * Input: time  
 *--------------------------------------------------------------------------------*/

static double wpan_backoff_period_boundary_get_(double Time) {

	double next_backoff_period_boundary;
	double aUnitBackoffPeriod_Sec;
	
	/* Stack tracing enrty point */
	FIN(wpan_backoff_period_boundary_get_);
	
	aUnitBackoffPeriod_Sec = Symbols2Sec(aUnitBackoffPeriod, WPAN_DATA_RATE);
	next_backoff_period_boundary = SF.BI_Boundary + (wpan_backoff_period_index_get_(Time) * aUnitBackoffPeriod_Sec);

	return (next_backoff_period_boundary);
	
	/* Stack tracing exit point */
	FRET(next_backoff_period_boundary);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_cca_defer
 *
 * Description:	check if the requested transaction can be completed before the end of the current CAP
 *							|CCA1|-|CCA2|-|PHY|FRAME|-||macAckWaitDuration + |PHY|ACK||-|IFS| or
 *							|CCA1|-|CCA2|-|PHY|FRAME|-|IFS|
 *             
 * No parameters  
 *--------------------------------------------------------------------------------*/

static Boolean wpan_cca_defer() {

	double end_cap_time;
	double remaining_cap_time ;
	double tx_time;
	Packet* frame_to_send;
	int IFS;
	int ack_request;
	int frame_len_symbol;
	double ack_time_Symbol; // time need for ACK
	
	/* Stack tracing enrty point */
	FIN(wpan_cca_defer);
	
	frame_to_send = op_subq_pk_access(SUBQ_ZERO,OPC_QPOS_HEAD); // obtains a pointer to a packet stored in the specified queue
	
	/* get the frame size*/
	frame_len_symbol = Bits2Symbols((int) op_pk_total_size_get(frame_to_send));
	
	/* get the corresponding IFS of the frame*/
	IFS = wpan_ifs_symbol_get(frame_to_send);
	
	/*check if any acknowledgment is necessary for this frame */
	op_pk_nfd_get (frame_to_send, "Ack Request", &ack_request);
	
	if (ack_request)
		ack_time_Symbol = macAckWaitDuration+Bits2Symbols(ACK_FRAME_SIZE_BITS)+Bits2Symbols(PHY_HEADER_SIZE);
		//ack_time_Symbol = (aTurnaroundTime_Symbol + aUnitBackoffPeriod)+Bits2Symbols(ACK_FRAME_SIZE_BITS)+Bits2Symbols(PHY_HEADER_SIZE);
	else 
		ack_time_Symbol = 0;
	
	/*check the time to perform complete transaction*/
	end_cap_time = SF.BI_Boundary + Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE);
	remaining_cap_time = end_cap_time - wpan_backoff_period_boundary_get();	
	
	/* |CCA1|-|CCA2|-|PHY|FRAME|-||macAckWaitDuration + |PHY|ACK||-|IFS| or |CCA1|-|CCA2|-|PHY|FRAME|-|IFS|*/ 
	tx_time = Symbols2Sec(((2*aUnitBackoffPeriod)+Bits2Symbols(PHY_HEADER_SIZE)+frame_len_symbol+ack_time_Symbol+IFS),WPAN_DATA_RATE);	
	
	SF.CCA_DEFERRED = OPC_TRUE; // CCA deferred to next CAP (cca_time > remaining_cap_time)
	if (tx_time <= remaining_cap_time) {	// perform CCA in this CAP
		SF.CCA_DEFERRED = OPC_FALSE;
		wpan_cca_perform (1);	
	}
	
	if (enable_log && SF.CCA_DEFERRED) {			
		fprintf (log,"t=%f   -> -------------- CCA DEFERRED --------------   \n\n", op_sim_time());
		printf (" [Node %s] t=%f  -> --------------  CCA DEFERRED --------------   \n\n", my_attributes.name, op_sim_time());
	}
	
	if (enable_log) {
		printf ("-------------------------- CCA -----------------------------------\n", my_attributes.name);
		printf (" [Node %s] ENTERS CCA AT %f\n", my_attributes.name, op_sim_time());
		printf ("   Beacon Boundary = %f\n", SF.BI_Boundary);
		printf ("   NB = %d\n",csma.NB);
		printf ("   CW = %d\n",csma.CW);
		printf ("   BE = %d\n",csma.BE);	
		printf ("   * Frame Size  = %d Symbols\n", frame_len_symbol);
		printf ("   * IFS         = %d Symbols\n", IFS);	
		printf ("       + Requiered TX Time  = %f sec \n", tx_time);
		printf ("       + CCA Deferred       = %d  \n", SF.CCA_DEFERRED);
		printf ("       + Remaining CAP Time = %f sec \n", remaining_cap_time);
		printf ("   Beacon Interval = %f  sec %d\n", Symbols2Sec(SF.BI, WPAN_DATA_RATE), SF.BI);
		printf ("   Slot Duration = %f sec \n", Symbols2Sec(SF.slot_duration, WPAN_DATA_RATE));
		printf ("   Backoff Boundary Index = %d  \n",wpan_backoff_period_index_get());
		printf ("   Current Time Slot = %d \n", wpan_current_time_slot_get());
		printf ("  \n   CAP STATUT = %s  \n", boolean2string(SF.CAP_ACTIVE));
		printf ("   CFP STATUT = %s  \n", boolean2string(SF.CFP_ACTIVE));
		printf ("   SLEEP STATUT = %s \n", boolean2string(SF.SLEEP));
		printf ("----------------------------------------------------------------------------\n\n\n");
	}
	
	op_stat_write(statistic_vector.deferred_cca, SF.CCA_DEFERRED);
	op_stat_write(statistic_vector.deferred_cca_backoff, SF.CCA_DEFERRED);
	return(SF.CCA_DEFERRED);
	
	/* Stack tracing exit point */
	FRET(SF.CCA_DEFERRED);
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_cca_perform
 *
 * Description:	check if it is possible to perform CCA analyses [CCA 1 (CW=2) -> CCA 2 (CW=1)]
 *             
 *
 * Input :  cca_index - CCA index
 *--------------------------------------------------------------------------------*/

static void wpan_cca_perform(int cca_index) {
	
	double cca_period;	
	
	/* Stack tracing enrty point */
	FIN(wpan_cca_perform);
	
	if (enable_log) {
		fprintf (log,"t=%f  -------------- PERFORM CCA %d (CW=%d) --------------  \n\n", op_sim_time(), 3-csma.CW, csma.CW);
		printf (" [Node %s] t=%f  -------------- PERFORM CCA %d (CW=%d) -------------- \n\n", my_attributes.name, op_sim_time(), 3-csma.CW, csma.CW);
	}

	if (SF.CCA_DEFERRED == OPC_FALSE) {	
		if (cca_index == 1){ /* CCA 1 (CW=2)*/
			if (csma.CW != 2)			
				op_sim_end ("wpan_cca_perform", "CW !=2 AT CCA 1","","");
			
			cca_period = op_sim_time() + Symbols2Sec(WPAN_CCA_DETECTION_TIME_Symbols, WPAN_DATA_RATE);
			op_intrpt_schedule_self (op_sim_time(), CCA_START_CODE);
		} else if (cca_index == 2) {/* CCA 2 (CW=1)*/
			if (csma.CW != 1)
				op_sim_end ("wpan_cca_perform", "CW !=1 AT CCA 2","","");
			
			cca_period = wpan_backoff_period_boundary_get() + Symbols2Sec(WPAN_CCA_DETECTION_TIME_Symbols, WPAN_DATA_RATE);
			op_intrpt_schedule_self (wpan_backoff_period_boundary_get(), CCA_START_CODE);
		} else if (cca_index == 3) {/* Deferred CCA resumed after the start of the CAP (CW=2)*/
			if (csma.CW != 2)
				op_sim_end("wpan_cca_perform", "CW !=2 AT CCA 1 After a Resume","","");
			
			cca_period = wpan_backoff_period_boundary_get()+Symbols2Sec(WPAN_CCA_DETECTION_TIME_Symbols, WPAN_DATA_RATE);
			op_intrpt_schedule_self (max_double(wpan_backoff_period_boundary_get(), op_sim_time()), CCA_START_CODE);
		}	

		op_intrpt_schedule_self (cca_period, CCA_EXPIRATION_CODE);
	}
	else {
	/*do nothing, just wait when the CCA comes back */
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_ifs_symbol_get
 *
 * Description:	get the intra-frame spacing of a given packet based on its size (MPDU)
 *             
 *  Input :  frame_MPDU - MAC frame (MPDU)
 *--------------------------------------------------------------------------------*/

static int wpan_ifs_symbol_get(Packet* frame_MPDU) {

	int frame_len;
	int ifs;
	
	/* Stack tracing enrty point */
	FIN(wpan_ifs_symbol_get);
	
	frame_len = op_pk_total_size_get(frame_MPDU);
	
	ifs = aMinSIFSPeriod;
	
	if (frame_len > aMaxSIFSFrameSize_Bits) 
		ifs = aMinLIFSPeriod;

	return (ifs);
	
	/* Stack tracing exit point */
	FRET(ifs);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_cca_expire
 *
 * Description:	check if it is possible to perform CCA analyses 
 *             
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_cca_expire() {	

	/* Stack tracing enrty point */
	FIN(wpan_cca_expire);
	
	if (enable_log) {
		fprintf(log,"t=%f   -------- CCA EXPIRES ----------->  CHANNEL IDLE = %s \n\n",op_sim_time(), boolean2string(csma.CCA_CHANNEL_IDLE));
		printf(" [Node %s] t=%f  -------- CCA EXPIRES ----------->  CHANNEL IDLE = %s   \n",my_attributes.name,op_sim_time(), boolean2string(csma.CCA_CHANNEL_IDLE));
	}

	/* check at the CCA end, if the channel is busy */
	if (op_stat_local_read(RX_BUSY_STAT) == 1.0)
		csma.CCA_CHANNEL_IDLE = OPC_FALSE;
	
	if (csma.CW == 2) {
		op_stat_write(statistic_vector.ch_busy_cca1, 1-csma.CCA_CHANNEL_IDLE);
		op_stat_write(statistic_vector.ch_idle_cca1, csma.CCA_CHANNEL_IDLE);
	} else {
		op_stat_write(statistic_vector.ch_busy_cca2, 1-csma.CCA_CHANNEL_IDLE);
		op_stat_write(statistic_vector.ch_idle_cca2, csma.CCA_CHANNEL_IDLE);
	}
	
	/*THE CHANNEL IS BUSY */			
	if (csma.CCA_CHANNEL_IDLE == OPC_FALSE) {
		csma.NB = csma.NB+1;
		csma.CW = 2;
		csma.BE = min_int(csma.BE+1,aMaxBE);
		
		if (enable_log) {
			fprintf(log,"t=%f  ------ CCA BUSY CHANNEL - GO BACK TO BACKOFF ------> NB = %d \n\n",op_sim_time(), csma.NB);
			printf(" [Node %s] t=%f  ------ CCA BUSY CHANNEL - GO BACK TO BACKOFF ------> NB = %d \n", my_attributes.name, op_sim_time(), csma.NB);
		}
				
		if (csma.NB <= csma.MAX_CSMA_BACKOFF) { /*redo another backoff */
			wpan_backoff_delay_set ();
			op_intrpt_schedule_self (op_sim_time(), RETURN_TO_BACKOFF_CODE);
		}
		else {	/* report a transmission failure */
			
			if (enable_log) {
				fprintf(log,"t=%f  -------- CCA TRANSMISSION FAILURE - PACKET WAS NOT SENT \n\n", op_sim_time());
				printf(" [Node %s] t=%f  -------- CCA TRANSMISSION FAILURE - PACKET WAS PACKET NOT SENT -------    \n", my_attributes.name, op_sim_time());
			}
			
			op_stat_write(statistic_vector.failure, 1.0);
			op_stat_write(statistic_vector.success, 0.0);
			op_intrpt_schedule_self (op_sim_time(), FAILURE_CODE); 
		}
	} else { /*THE CHANNEL IS IDLE */
		/*check the value of the contention windows*/
		csma.CW = csma.CW-1;
			
		if (csma.CW != 0){ /* perform the second CCA. we don't test if cca will be deferred only in the first test */
				
			if (enable_log) {
				fprintf (log, "t=%f  -------- CCA IDLE CHANNEL + GO CCA 2nd STEP  ------- \n\n", op_sim_time());	
				printf (" [Node %s] t=%f  -------- CCA IDLE CHANNEL + GO CCA 2nd STEP  ------- \n", my_attributes.name, op_sim_time());
			}

			wpan_cca_perform (2);
		} else { /*SUCCESS (CW=0) - FRAME TRANSMISSION */
				
			if (enable_log) {
				fprintf(log,"t=%f  -------- CCA IDLE CHANNEL - TX IS SCHEDULED ON BACKOFF BOUNDARY [%f sec]  \n\n",op_sim_time(), wpan_backoff_period_boundary_get());
				printf("\n [Node %s] t=%f  -------- CCA IDLE CHANNEL - TX IS SCHEDULED ON BACKOFF BOUNDARY [%f sec]  \n\n", my_attributes.name, op_sim_time(), wpan_backoff_period_boundary_get());
			}
		
			op_stat_write(statistic_vector.failure, 0.0);
			op_stat_write(statistic_vector.success, 1.0);
			op_intrpt_schedule_self (wpan_backoff_period_boundary_get(), START_TRANSMISSION_CODE); 				
		}				
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_update_sequence_number()
 *
 * Description:	generate a random sequence number to not interfere with others
 *
 * No parameters  
 *--------------------------------------------------------------------------------*/

static int wpan_update_sequence_number() {
	
	int seq_num;
	int max_seq;
	
	/* Stack tracing enrty point */
	FIN(wpan_update_sequence_number);
	
	max_seq = 255;
		
	seq_num = floor (op_dist_uniform (max_seq));
	
	return(seq_num);
	
	/* Stack tracing exit point */
	FRET(seq_num);
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_battery_update_tx
 *
 * Description:	send information about the operation to do to the battery module 
 *
 * Input : 	pksize - size of sent packet [bits]
 *--------------------------------------------------------------------------------*/
static void wpan_battery_update_tx(double pksize) {
	
	Ici * iciptr;
	
	/* Stack tracing enrty point */
	FIN(wpan_battery_update_tx);
	
	iciptr = op_ici_create ("wpan_battery_ici_format");
	op_ici_attr_set (iciptr, "Packet Size", pksize);
	op_ici_attr_set (iciptr, "WPAN DATA RATE", WPAN_DATA_RATE);
	op_ici_install (iciptr);
	op_intrpt_schedule_remote (op_sim_time(), PACKET_TX_CODE, my_attributes.my_battery); 
	op_ici_install (OPC_NIL);
	
	/* Stack tracing exit point */
	FOUT;
}




/*--------------------------------------------------------------------------------
 * Function:	wpan_battery_update_rx
 *
 * Description:	send information about the operation to do to the battery module 
 *
 * Input :	pksize - size of received packet
 *			frame_type - type of received packet
 *--------------------------------------------------------------------------------*/
static void wpan_battery_update_rx(double pksize, int frame_type) {
	
	Ici * iciptr;
	
	/* Stack tracing enrty point */
	FIN(wpan_battery_update_rx);
	
	iciptr = op_ici_create ("wpan_battery_ici_format");
	op_ici_attr_set (iciptr, "Packet Size", pksize);
	op_ici_attr_set (iciptr, "WPAN DATA RATE", WPAN_DATA_RATE);
	op_ici_attr_set (iciptr, "Frame Type", frame_type);
	op_ici_install (iciptr);
	op_intrpt_schedule_remote (op_sim_time(), PACKET_RX_CODE, my_attributes.my_battery); 
	op_ici_install (OPC_NIL);
	
	/* Stack tracing exit point */
	FOUT;
}


/*-----------------------------------------------------------------
 *     UTILITY FUNCTIONS
 *-----------------------------------------------------------------
*/

/*-----------------------------------------------------------------------------
 * Function:	gts_nested_list_mem_copy_create
 *
 * Description:	provide a hard-copy of the GTS_list (list containing wpan_gts_descriptor records).
 *				This function is used in the "op_pk_nfd_set_ptr()" as a copy procedure and therefore
 *				it has to match the following function prototype: void* fce (void*, usingned int);
 *              
 * Input :	list_ptr - pointer to the GTS_list to be copied
 *			size - formal parameter - is not used in this function
 *
 * Return :	void* - pointer to the copy of the GTS_list
 *-----------------------------------------------------------------------------*/

static void* gts_nested_list_mem_copy_create(void* list_ptr, unsigned int size)
{
	PrgT_List* list_copy;
	void* from_list_ptr;
	wpan_gts_descriptor* gts_descriptor_ptr;
	int i;	
	
	/* Stack tracing enrty point */
	FIN(gts_nested_list_mem_copy_create);
	
	/* allocate an empty list */
	list_copy = op_prg_list_create ();
	
	for (i=0; i<op_prg_list_size ((PrgT_List* ) list_ptr); i++) {
		from_list_ptr = op_prg_list_access ((PrgT_List* ) list_ptr, i);
		
		/* memory allocation */
		gts_descriptor_ptr	= (wpan_gts_descriptor *) op_prg_mem_alloc (sizeof (wpan_gts_descriptor));
		
		gts_descriptor_ptr = (wpan_gts_descriptor *) from_list_ptr;
		gts_descriptor_ptr->device_short_address = ((wpan_gts_descriptor *) from_list_ptr)->device_short_address;
		gts_descriptor_ptr->start_slot = ((wpan_gts_descriptor *) from_list_ptr)->start_slot;
		gts_descriptor_ptr->length = ((wpan_gts_descriptor *) from_list_ptr)->length;
		
		/* insert the GTS descriptor onto the list tail */
		op_prg_list_insert (list_copy, gts_descriptor_ptr, OPC_LISTPOS_TAIL);
	}	
	
	return (void* ) list_copy;
	
	/* Stack tracing exit point */
	FRET((void* ) list_copy);
}


/*-----------------------------------------------------------------------------
 * Function:	gts_nested_list_mem_free
 *
 * Description:	deallocate a GTS_list (list containing wpan_gts_descriptor records)
 *				that was previously allocated. 
 *				This function is used in the "op_pk_nfd_set_ptr()" as a deallocation procedure 
 *				and therefore it has to match the following function prototype: void* fce (void* );
 *              
 * Input :  from_ptr - pointer to the GTS_list to be deallocated
 *-----------------------------------------------------------------------------*/

static void gts_nested_list_mem_free(void* from_ptr)
{
	/* Stack tracing enrty point */
	FIN(gts_nested_list_mem_free);
	
	/* deallocate memory of the list */
	op_prg_mem_free (from_ptr);
	
	/* Stack tracing exit point */
	FOUT;
}


/*-----------------------------------------------------------------------------
 * Function:	queue_status
 *
 * Description:	print the status of each subqueue
 *              
 * No parameters
 *-----------------------------------------------------------------------------*/

static void queue_status() {
	
	Objid queue_objid;
	Objid subq_objid;
	double bit_capacity;
	double pk_capacity;
	int subq_count;
	int i;
	
	/* Stack tracing enrty point */
	FIN(queue_status);

	/* get the subqueues object ID */
	op_ima_obj_attr_get (my_attributes.objid, "subqueue", &queue_objid);
	
	/* obtain how many subqueues exist */
	subq_count = op_topo_child_count (queue_objid, OPC_OBJMTYPE_ALL);
	
	/* get the object IDs of each subqueue and get subqueue attributes  */
	for (i = 0; i < subq_count; i++)
	{
		/* Obtain object ID of the ith subqueue */
		subq_objid = op_topo_child (queue_objid, OPC_OBJMTYPE_ALL, i);
		
		/* Get current subqueue attribute settings */
		op_ima_obj_attr_get (subq_objid, "bit capacity", &bit_capacity);
		op_ima_obj_attr_get (subq_objid, "pk capacity", &pk_capacity);
		
		if (op_subq_empty(i)) {
			if (enable_log) {	
				fprintf(log,"t=%f  -> Subqueue #%d is empty, wait for MAC frames \n\t -> capacity [%#e frames, %#e bits]. \n\n", op_sim_time(), i, pk_capacity, bit_capacity);
				printf(" [Node %s] t=%f  -> Subqueue #%d is empty, wait for MAC frames \n\t -> capacity [%#e frames, %#e bits]. \n\n", my_attributes.name, op_sim_time(), i, pk_capacity, bit_capacity);
			}
		} else {
			if (enable_log) {	 
				fprintf(log,"t=%f  -> Subqueue #%d is non empty, \n\t -> occupied space [%#e frames, %#e bits] - empty space [%#e frames, %#e bits] \n\n", op_sim_time(), i, op_subq_stat (i, OPC_QSTAT_PKSIZE), op_subq_stat (i, OPC_QSTAT_BITSIZE), op_subq_stat (i, OPC_QSTAT_FREE_PKSIZE), op_subq_stat (i, OPC_QSTAT_FREE_BITSIZE));
				printf(" [Node %s] t=%f  -> Subqueue #%d is non empty,\n\t -> occupied space [%#e frames, %#e bits] - empty space [%#e frames, %#e bits] \n\n", my_attributes.name, op_sim_time(), i, op_subq_stat (i, OPC_QSTAT_PKSIZE), op_subq_stat (i, OPC_QSTAT_BITSIZE), op_subq_stat (i, OPC_QSTAT_FREE_PKSIZE), op_subq_stat (i, OPC_QSTAT_FREE_BITSIZE));
			}
		}	
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*-----------------------------------------------------------------------------
 * Function:	cap_is_not_active
 *
 * Description:	
 *              
 * No parameters
 *-----------------------------------------------------------------------------*/

static void cap_is_not_active() {

	/* Stack tracing enrty point */
	FIN(cap_is_not_active);
	
	printf(" [Node %s] CAP IS NOT ACTIVE :( t = %20.10f  END OF CAP = %20.10f \n", my_attributes.name, op_sim_time(), SF.BI_Boundary+Symbols2Sec(((SF.Final_CAP_Slot+1)*SF.slot_duration), WPAN_DATA_RATE));
	printf("         -> RESUME_BACKOFF_TIMER = %d  backoff_timer = %f  BACKOFF BOUNDARY =%f\n\n", SF.RESUME_BACKOFF_TIMER,  SF.backoff_timer, wpan_backoff_period_boundary_get());
	op_sim_end("?????","","","");
	
	/* Stack tracing exit point */
	FOUT;
}



/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

/* Undefine shortcuts to state variables because the */
/* following functions are part of the state class */
#undef my_attributes
#undef csma
#undef GTS
#undef SF
#undef mac_attributes
#undef log
#undef enable_log
#undef statistic_vector
#undef statistic_global_vector
#undef ack_sequence_number
#undef backoff_start_time
#undef Final_CAP_slot_next
#undef is_waiting_GTS_confirm
#undef is_deallocation_req_sent
#undef wait_GTS_confirm_count
#undef is_GTS_tx_time_active
#undef sent_gts_bits
#undef gts_statistic_vector
#undef gts_statistics
#undef gts_pkt_delay
#undef gts_queue_capacity
#undef start_GTS_transmission
#undef waiting_for_first_beacon

/* Access from C kernel using C linkage */
extern "C"
{
	VosT_Obtype _op_wpan_mac_process_init (int * init_block_ptr);
	VosT_Address _op_wpan_mac_process_alloc (VosT_Obtype, int);
	void wpan_mac_process (OP_SIM_CONTEXT_ARG_OPT)
		{
		((wpan_mac_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->wpan_mac_process (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_wpan_mac_process_svar (void *, const char *, void **);

	void _op_wpan_mac_process_diag (OP_SIM_CONTEXT_ARG_OPT)
		{
		((wpan_mac_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->_op_wpan_mac_process_diag (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_wpan_mac_process_terminate (OP_SIM_CONTEXT_ARG_OPT)
		{
		/* The destructor is the Termination Block */
		delete (wpan_mac_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr);
		}


} /* end of 'extern "C"' */




/* Process model interrupt handling procedure */


void
wpan_mac_process_state::wpan_mac_process (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_mac_process_state::wpan_mac_process ());
	try
		{
		/* Temporary Variables */
		/* the coordinates of the PAN coordinator	*/
		//double xpan = 300;
		//double ypan = 300;
		//double zpan = 0;
		
		//double distance;
		/* End of Temporary Variables */


		FSM_ENTER ("wpan_mac_process")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "wpan_mac_process [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [init enter execs]", state0_enter_exec)
				{
				wpan_mac_init ();
				wpan_gts_scheduling ();
				
				op_intrpt_priority_set (OPC_INTRPT_SELF, START_OF_GTS_PERIOD, -4);
				op_intrpt_priority_set (OPC_INTRPT_SELF, END_OF_CAP_PERIOD_CODE, -2);
				op_intrpt_priority_set (OPC_INTRPT_SELF, END_OF_CFP_PERIOD_CODE, -2);
				op_intrpt_priority_set (OPC_INTRPT_SELF, BEACON_INTERVAL_CODE, -2);
				op_intrpt_priority_set (OPC_INTRPT_SELF, END_OF_GTS_PERIOD, 2);
				op_intrpt_priority_set (OPC_INTRPT_SELF, BACKOFF_EXPIRATION_CODE, 15); // the highest priority
				
				/* the coordinates of PAN coordinator should be set (xpan, ypan, zpan)	*/ 
				//distance = sqrt(((xpan-my_attributes.x)*(xpan-my_attributes.x))+((ypan-my_attributes.y)*(ypan-my_attributes.y))+((zpan-my_attributes.altitude)*(zpan-my_attributes.altitude)));
				//printf ("[Node %s]    t= %f\n   -> Distance From PAN Coordinator =%f --------------------\n",my_attributes.name, op_sim_time(), distance);
				
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "wpan_mac_process [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "wait_beacon", "tr_2", "wpan_mac_process [init -> wait_beacon : default / ]")
				/*---------------------------------------------------------*/



			/** state (wait_beacon) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "wait_beacon", state1_enter_exec, "wpan_mac_process [wait_beacon enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [wait_beacon enter execs]", state1_enter_exec)
				{
				/************************************************************************
				In this state a node check if it is a PAN Coordinator:
				- Node is a PAN Coordinator : it waits a beacon frame from the Sychro module
				- Node is a End Device : it waits until a beacon frame from the network. 
				*/
				    
				/* get the packet from the stream */
				switch (op_intrpt_type()) {
					case OPC_INTRPT_STRM : 
					{
						wpan_parse_incoming_frame ();			
						op_intrpt_schedule_self (op_sim_time (), DEFAULT_CODE); // -> to IDLE state
						break;
					};
					default :
					{
					};
				}
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"wpan_mac_process")


			/** state (wait_beacon) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "wait_beacon", "wpan_mac_process [wait_beacon exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [wait_beacon exit execs]", state1_exit_exec)
				{
				//wpan_mac_interrupt_process();
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (wait_beacon) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_mac_process [wait_beacon trans conditions]", state1_trans_conds)
			FSM_INIT_COND (DEFAULT_INTRPT)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("wait_beacon")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, queue_status();, "DEFAULT_INTRPT", "queue_status()", "wait_beacon", "idle", "tr_10", "wpan_mac_process [wait_beacon -> idle : DEFAULT_INTRPT / queue_status()]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ;, "default", "", "wait_beacon", "wait_beacon", "tr_45", "wpan_mac_process [wait_beacon -> wait_beacon : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "idle", state2_enter_exec, "wpan_mac_process [idle enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [idle enter execs]", state2_enter_exec)
				{
				//if (enable_log)
				//	printf(" [Node %s]  wpan_mac_process - in idle state \n", my_attributes.name);
				
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"wpan_mac_process")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "idle", "wpan_mac_process [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [idle exit execs]", state2_exit_exec)
				{
				/* Call the interrupt processing routing for each interrupt */
				wpan_mac_interrupt_process();
				}
				FSM_PROFILE_SECTION_OUT (state2_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_mac_process [idle trans conditions]", state2_trans_conds)
			FSM_INIT_COND (PACKET_READY_TO_SEND)
			FSM_TEST_COND (GTS_START)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 3, state3_enter_exec, ;, "PACKET_READY_TO_SEND", "", "idle", "init_backoff", "tr_34", "wpan_mac_process [idle -> init_backoff : PACKET_READY_TO_SEND / ]")
				FSM_CASE_TRANSIT (1, 6, state6_enter_exec, wpan_gts_slot_init();, "GTS_START", "wpan_gts_slot_init()", "idle", "gts_slot", "tr_59", "wpan_mac_process [idle -> gts_slot : GTS_START / wpan_gts_slot_init()]")
				FSM_CASE_TRANSIT (2, 2, state2_enter_exec, ;, "default", "", "idle", "idle", "tr_41", "wpan_mac_process [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (init_backoff) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "init_backoff", state3_enter_exec, "wpan_mac_process [init_backoff enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [init_backoff enter execs]", state3_enter_exec)
				{
				/* This state initializes the csma/ca parameters */
				wpan_backoff_init();
				
				/*capture the time that the packet enters the backoff */
				backoff_start_time = op_sim_time();
				
				//if (enable_log)
				//	printf(" [Node %s]  wpan_mac_process - init_backoff state \n", my_attributes.name);
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (init_backoff) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "init_backoff", "wpan_mac_process [init_backoff exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [init_backoff exit execs]", state3_exit_exec)
				{
				/* set the backoff timer to a random value */
				wpan_backoff_delay_set();
				}
				FSM_PROFILE_SECTION_OUT (state3_exit_exec)


			/** state (init_backoff) transition processing **/
			FSM_TRANSIT_FORCE (4, state4_enter_exec, ;, "default", "", "init_backoff", "backoff_timer", "tr_31", "wpan_mac_process [init_backoff -> backoff_timer : default / ]")
				/*---------------------------------------------------------*/



			/** state (backoff_timer) enter executives **/
			FSM_STATE_ENTER_UNFORCED (4, "backoff_timer", state4_enter_exec, "wpan_mac_process [backoff_timer enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [backoff_timer enter execs]", state4_enter_exec)
				{
				//if (enable_log)
				//	printf(" [Node %s]   wpan_mac - in backoff_timer state \n", my_attributes.name);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (9,"wpan_mac_process")


			/** state (backoff_timer) exit executives **/
			FSM_STATE_EXIT_UNFORCED (4, "backoff_timer", "wpan_mac_process [backoff_timer exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [backoff_timer exit execs]", state4_exit_exec)
				{
				/* Call the interrupt processing routing for each interrupt */
				wpan_mac_interrupt_process();
				}
				FSM_PROFILE_SECTION_OUT (state4_exit_exec)


			/** state (backoff_timer) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_mac_process [backoff_timer trans conditions]", state4_trans_conds)
			FSM_INIT_COND (BACKOFF_EXPIRED && CAP_IS_ACTIVE)
			FSM_TEST_COND (BACKOFF_EXPIRED && !CAP_IS_ACTIVE)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("backoff_timer")
			FSM_PROFILE_SECTION_OUT (state4_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 5, state5_enter_exec, wpan_cca_defer();, "BACKOFF_EXPIRED && CAP_IS_ACTIVE", "wpan_cca_defer()", "backoff_timer", "CCA", "tr_32", "wpan_mac_process [backoff_timer -> CCA : BACKOFF_EXPIRED && CAP_IS_ACTIVE / wpan_cca_defer()]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, cap_is_not_active();, "BACKOFF_EXPIRED && !CAP_IS_ACTIVE", "cap_is_not_active()", "backoff_timer", "init_backoff", "tr_35", "wpan_mac_process [backoff_timer -> init_backoff : BACKOFF_EXPIRED && !CAP_IS_ACTIVE / cap_is_not_active()]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "default", "", "backoff_timer", "backoff_timer", "tr_29", "wpan_mac_process [backoff_timer -> backoff_timer : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (CCA) enter executives **/
			FSM_STATE_ENTER_UNFORCED (5, "CCA", state5_enter_exec, "wpan_mac_process [CCA enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [CCA enter execs]", state5_enter_exec)
				{
				//if (enable_log)
				//	printf(" [Node %s]  wpan_mac - in CCA state \n", my_attributes.name);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"wpan_mac_process")


			/** state (CCA) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "CCA", "wpan_mac_process [CCA exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [CCA exit execs]", state5_exit_exec)
				{
				/* Call the interrupt processing routing for each interrupt */
				wpan_mac_interrupt_process();
				}
				FSM_PROFILE_SECTION_OUT (state5_exit_exec)


			/** state (CCA) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_mac_process [CCA trans conditions]", state5_trans_conds)
			FSM_INIT_COND (CHANNEL_BUSY)
			FSM_TEST_COND (CCA_END)
			FSM_TEST_COND (GTS_START)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("CCA")
			FSM_PROFILE_SECTION_OUT (state5_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 4, state4_enter_exec, wpan_backoff_update();, "CHANNEL_BUSY", "wpan_backoff_update()", "CCA", "backoff_timer", "tr_38", "wpan_mac_process [CCA -> backoff_timer : CHANNEL_BUSY / wpan_backoff_update()]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, queue_status();, "CCA_END", "queue_status()", "CCA", "idle", "tr_40", "wpan_mac_process [CCA -> idle : CCA_END / queue_status()]")
				FSM_CASE_TRANSIT (2, 6, state6_enter_exec, wpan_gts_slot_init();, "GTS_START", "wpan_gts_slot_init()", "CCA", "gts_slot", "tr_61", "wpan_mac_process [CCA -> gts_slot : GTS_START / wpan_gts_slot_init()]")
				FSM_CASE_TRANSIT (3, 5, state5_enter_exec, ;, "default", "", "CCA", "CCA", "tr_46", "wpan_mac_process [CCA -> CCA : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (gts_slot) enter executives **/
			FSM_STATE_ENTER_UNFORCED (6, "gts_slot", state6_enter_exec, "wpan_mac_process [gts_slot enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [gts_slot enter execs]", state6_enter_exec)
				{
				//if (enable_log)
				//	printf(" [Node %s]  wpan_mac_process - in GTS slot state \n", my_attributes.name);
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (13,"wpan_mac_process")


			/** state (gts_slot) exit executives **/
			FSM_STATE_EXIT_UNFORCED (6, "gts_slot", "wpan_mac_process [gts_slot exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_mac_process [gts_slot exit execs]", state6_exit_exec)
				{
				/* Call the interrupt processing routing for each interrupt */
				wpan_mac_interrupt_process();
				}
				FSM_PROFILE_SECTION_OUT (state6_exit_exec)


			/** state (gts_slot) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_mac_process [gts_slot trans conditions]", state6_trans_conds)
			FSM_INIT_COND (GTS_STOP_IDLE)
			FSM_TEST_COND (GTS_STOP_CCA)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("gts_slot")
			FSM_PROFILE_SECTION_OUT (state6_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "GTS_STOP_IDLE", "", "gts_slot", "idle", "tr_60", "wpan_mac_process [gts_slot -> idle : GTS_STOP_IDLE / ]")
				FSM_CASE_TRANSIT (1, 5, state5_enter_exec, ;, "GTS_STOP_CCA", "", "gts_slot", "CCA", "tr_62", "wpan_mac_process [gts_slot -> CCA : GTS_STOP_CCA / ]")
				FSM_CASE_TRANSIT (2, 6, state6_enter_exec, ;, "default", "", "gts_slot", "gts_slot", "tr_63", "wpan_mac_process [gts_slot -> gts_slot : default / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wpan_mac_process")
		}
	catch (...)
		{
		Vos_Error_Print (VOSC_ERROR_ABORT,
			(const char *)VOSC_NIL,
			"Unhandled C++ exception in process model (wpan_mac_process)",
			(const char *)VOSC_NIL, (const char *)VOSC_NIL);
		}
	}




void
wpan_mac_process_state::_op_wpan_mac_process_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}

void
wpan_mac_process_state::operator delete (void* ptr)
	{
	FIN (wpan_mac_process_state::operator delete (ptr));
	Vos_Poolmem_Dealloc (ptr);
	FOUT
	}

wpan_mac_process_state::~wpan_mac_process_state (void)
	{

	FIN (wpan_mac_process_state::~wpan_mac_process_state ())


	/* No Termination Block */


	FOUT
	}


#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

void *
wpan_mac_process_state::operator new (size_t)
#if defined (VOSD_NEW_BAD_ALLOC)
		throw (VOSD_BAD_ALLOC)
#endif
	{
	void * new_ptr;

	FIN_MT (wpan_mac_process_state::operator new ());

	new_ptr = Vos_Alloc_Object (wpan_mac_process_state::obtype);
#if defined (VOSD_NEW_BAD_ALLOC)
	if (new_ptr == VOSC_NIL) throw VOSD_BAD_ALLOC();
#endif
	FRET (new_ptr)
	}

/* State constructor initializes FSM handling */
/* by setting the initial state to the first */
/* block of code to enter. */

wpan_mac_process_state::wpan_mac_process_state (void) :
		_op_current_block (0)
	{
#if defined (OPD_ALLOW_ODB)
		_op_current_state = "wpan_mac_process [init enter execs]";
#endif
	}

VosT_Obtype
_op_wpan_mac_process_init (int * init_block_ptr)
	{
	FIN_MT (_op_wpan_mac_process_init (init_block_ptr))

	wpan_mac_process_state::obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_mac_process)",
		sizeof (wpan_mac_process_state));
	*init_block_ptr = 0;

	FRET (wpan_mac_process_state::obtype)
	}

VosT_Address
_op_wpan_mac_process_alloc (VosT_Obtype, int)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_mac_process_state * ptr;
	FIN_MT (_op_wpan_mac_process_alloc ())

	/* New instance will have FSM handling initialized */
#if defined (VOSD_NEW_BAD_ALLOC)
	try {
		ptr = new wpan_mac_process_state;
	} catch (const VOSD_BAD_ALLOC &) {
		ptr = VOSC_NIL;
	}
#else
	ptr = new wpan_mac_process_state;
#endif
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_mac_process_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_mac_process_state		*prs_ptr;

	FIN_MT (_op_wpan_mac_process_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_mac_process_state *)gen_ptr;

	if (strcmp ("my_attributes" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_attributes);
		FOUT
		}
	if (strcmp ("csma" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->csma);
		FOUT
		}
	if (strcmp ("GTS" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GTS);
		FOUT
		}
	if (strcmp ("SF" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SF);
		FOUT
		}
	if (strcmp ("mac_attributes" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mac_attributes);
		FOUT
		}
	if (strcmp ("log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->log);
		FOUT
		}
	if (strcmp ("enable_log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->enable_log);
		FOUT
		}
	if (strcmp ("statistic_vector" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->statistic_vector);
		FOUT
		}
	if (strcmp ("statistic_global_vector" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->statistic_global_vector);
		FOUT
		}
	if (strcmp ("ack_sequence_number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_sequence_number);
		FOUT
		}
	if (strcmp ("backoff_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->backoff_start_time);
		FOUT
		}
	if (strcmp ("Final_CAP_slot_next" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Final_CAP_slot_next);
		FOUT
		}
	if (strcmp ("is_waiting_GTS_confirm" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->is_waiting_GTS_confirm);
		FOUT
		}
	if (strcmp ("is_deallocation_req_sent" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->is_deallocation_req_sent);
		FOUT
		}
	if (strcmp ("wait_GTS_confirm_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wait_GTS_confirm_count);
		FOUT
		}
	if (strcmp ("is_GTS_tx_time_active" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->is_GTS_tx_time_active);
		FOUT
		}
	if (strcmp ("sent_gts_bits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sent_gts_bits);
		FOUT
		}
	if (strcmp ("gts_statistic_vector" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->gts_statistic_vector);
		FOUT
		}
	if (strcmp ("gts_statistics" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->gts_statistics);
		FOUT
		}
	if (strcmp ("gts_pkt_delay" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->gts_pkt_delay);
		FOUT
		}
	if (strcmp ("gts_queue_capacity" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->gts_queue_capacity);
		FOUT
		}
	if (strcmp ("start_GTS_transmission" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->start_GTS_transmission);
		FOUT
		}
	if (strcmp ("waiting_for_first_beacon" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->waiting_for_first_beacon);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

