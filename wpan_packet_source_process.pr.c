/* Process model C form file: wpan_packet_source_process.pr.c */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_packet_source_process.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_packet_source_process_pr_c [] = "MIL_3_Tfile_Hdr_ 150A 30A op_runsim_dev 7 4B06782D 4B06782D 1 nb-pju jurcikp 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files					*/
// Distribution Modeling sub-package
#include <oms_dist_support.h>
#include "headers\wpan_math.h"
#include "headers\wpan_params.h"
#include "headers\wpan_struct.h"


/* Node configuration constants		*/


/* Special attribute values			*/
#define	SC_INFINITE_TIME		-1.0

/* Interrupt code values			*/
#define	SC_START			0
#define	SC_STOP				1
#define	SC_GENERATE_ACK		2
#define	SC_GENERATE_UNACK	3

/* Input and output streams		*/
#define	STRM_FROM_UNACK_TO_MAC	0
#define	STRM_FROM_ACK_TO_MAC	1


/* State machine conditions 		*/
#define	START					((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code () == SC_START))
#define	DISABLED				((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code () == SC_STOP))
#define	STOP					((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code () == SC_STOP))
#define	ACK_MSDU_GENERATE		((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code () == SC_GENERATE_ACK))
#define	UNACK_MSDU_GENERATE		((op_intrpt_type () == OPC_INTRPT_SELF) && (op_intrpt_code () == SC_GENERATE_UNACK))


/* Function prototypes.				*/
static void wpan_source_init (void); 
static void wpan_print_parameters (void);
static void wpan_ack_traffic_generate (void);
static void wpan_unack_traffic_generate (void);

/* Global variables.				*/
extern int app_sent_msdu_nbr; // Number of MSDU generated by the Application Layer
extern double app_sent_msdu_bits; // MSDUs sent by the Application Layer [kbits]



/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	double	                 		ack_start_time                                  ;	/* Time when this source will start its ack-MSDU generation activities. */
	double	                 		ack_stop_time                                   ;	/* Time when this source will stop its ack-MSDU generation activities. */
	OmsT_Dist_Handle	       		ack_msdu_interarrival_dist_ptr                  ;	/* PDF used to determine the interarrival times of the generated ack-MSDUs. */
	OmsT_Dist_Handle	       		ack_msdu_size_dist_ptr                          ;	/* PDF used to determine the sizes of generated ack-MSDUs. */
	char	                   		ack_msdu_interarrival_dist_str[128]             ;	/* PDF used to determine the interarrival times of the generated ack-MSDUs. */
	char	                   		ack_msdu_size_dist_str[128]                     ;	/* PDF used to determine the sizes of generated ack-MSDUs. */
	double	                 		unack_start_time                                ;	/* Time when this source will start its unack-MSDU generation activities. */
	double	                 		unack_stop_time                                 ;	/* Time when this source will stop its unack-MSDU generation activities. */
	OmsT_Dist_Handle	       		unack_msdu_interarrival_dist_ptr                ;	/* PDF used to determine the interarrival times of generated unack-MSDUs. */
	OmsT_Dist_Handle	       		unack_msdu_size_dist_ptr                        ;	/* PDF used to determine the sizes of generated unack-MSDUs. */
	char	                   		unack_msdu_interarrival_dist_str[128]           ;	/* PDF used to determine the interarrival times of generated unack-MSDUs. */
	char	                   		unack_msdu_size_dist_str[128]                   ;	/* PDF used to determine the sizes of generated unack-MSDUs. */
	int	                    		dest_mac_address                                ;	/* Destination MAC address for data transmission */
	char	                   		node_name[30]                                   ;	/* Name of the node */
	Objid	                  		parent_id                                       ;	/* Object ID of the parent object (node) */
	Boolean	                		enable_log                                      ;	/* Is the logging to the file enabled? */
	Stathandle	             		ack_bits_sent_hndl                              ;	/* Statistic handle for "Traffic Sent (bits/sec)" statistic. */
	Stathandle	             		ack_msdus_sent_hndl                             ;	/* Statistic handle for "Traffic Sent (MSDUs/sec)" statistic. */
	Stathandle	             		ack_msdu_size_hndl                              ;	/* Statistic handle for "MSDU Size (bits)" statistic. */
	Stathandle	             		ack_msdu_interarrival_time_hndl                 ;	/* Statistic handle for "MSDUt Interaarival Time (secs)" statistic. */
	Stathandle	             		ack_bits_sent_hndlG                             ;	/* Statistic handle for "Traffic Sent (bits/sec)" statistic. */
	Stathandle	             		ack_msdus_hndl                                  ;	/* Statistic handle for the total number of generated MSDUs. */
	Stathandle	             		ack_msdus_hndlG                                 ;
	Stathandle	             		unack_bits_sent_hndl                            ;	/* Statistic handle for "Traffic Sent (bits/sec)" statistic. */
	Stathandle	             		unack_msdus_sent_hndl                           ;	/* Statistic handle for "Traffic Sent (MSDUs/sec)" statistic. */
	Stathandle	             		unack_msdu_size_hndl                            ;	/* Statistic handle for "MSDU Size (bits)" statistic. */
	Stathandle	             		unack_msdu_interarrival_time_hndl               ;	/* Statistic handle for "MSDU Interaarival Time (secs)" statistic. */
	Stathandle	             		unack_bits_sent_hndlG                           ;	/* Statistic handle for "Traffic Sent (bits/sec)" statistic. */
	Stathandle	             		unack_msdus_hndl                                ;	/* Statistic handle for the total number of generated MSDUs. */
	Stathandle	             		unack_msdus_hndlG                               ;
	Evhandle	               		ack_next_msdu_evh                               ;	/* Event handle for the arrival of next acknowledged MSDU. */
	Evhandle	               		unack_next_msdu_evh                             ;	/* Event handle for the arrival of next unacknowledged MSDU. */
	} wpan_packet_source_process_state;

#define ack_start_time          		op_sv_ptr->ack_start_time
#define ack_stop_time           		op_sv_ptr->ack_stop_time
#define ack_msdu_interarrival_dist_ptr		op_sv_ptr->ack_msdu_interarrival_dist_ptr
#define ack_msdu_size_dist_ptr  		op_sv_ptr->ack_msdu_size_dist_ptr
#define ack_msdu_interarrival_dist_str		op_sv_ptr->ack_msdu_interarrival_dist_str
#define ack_msdu_size_dist_str  		op_sv_ptr->ack_msdu_size_dist_str
#define unack_start_time        		op_sv_ptr->unack_start_time
#define unack_stop_time         		op_sv_ptr->unack_stop_time
#define unack_msdu_interarrival_dist_ptr		op_sv_ptr->unack_msdu_interarrival_dist_ptr
#define unack_msdu_size_dist_ptr		op_sv_ptr->unack_msdu_size_dist_ptr
#define unack_msdu_interarrival_dist_str		op_sv_ptr->unack_msdu_interarrival_dist_str
#define unack_msdu_size_dist_str		op_sv_ptr->unack_msdu_size_dist_str
#define dest_mac_address        		op_sv_ptr->dest_mac_address
#define node_name               		op_sv_ptr->node_name
#define parent_id               		op_sv_ptr->parent_id
#define enable_log              		op_sv_ptr->enable_log
#define ack_bits_sent_hndl      		op_sv_ptr->ack_bits_sent_hndl
#define ack_msdus_sent_hndl     		op_sv_ptr->ack_msdus_sent_hndl
#define ack_msdu_size_hndl      		op_sv_ptr->ack_msdu_size_hndl
#define ack_msdu_interarrival_time_hndl		op_sv_ptr->ack_msdu_interarrival_time_hndl
#define ack_bits_sent_hndlG     		op_sv_ptr->ack_bits_sent_hndlG
#define ack_msdus_hndl          		op_sv_ptr->ack_msdus_hndl
#define ack_msdus_hndlG         		op_sv_ptr->ack_msdus_hndlG
#define unack_bits_sent_hndl    		op_sv_ptr->unack_bits_sent_hndl
#define unack_msdus_sent_hndl   		op_sv_ptr->unack_msdus_sent_hndl
#define unack_msdu_size_hndl    		op_sv_ptr->unack_msdu_size_hndl
#define unack_msdu_interarrival_time_hndl		op_sv_ptr->unack_msdu_interarrival_time_hndl
#define unack_bits_sent_hndlG   		op_sv_ptr->unack_bits_sent_hndlG
#define unack_msdus_hndl        		op_sv_ptr->unack_msdus_hndl
#define unack_msdus_hndlG       		op_sv_ptr->unack_msdus_hndlG
#define ack_next_msdu_evh       		op_sv_ptr->ack_next_msdu_evh
#define unack_next_msdu_evh     		op_sv_ptr->unack_next_msdu_evh

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_packet_source_process_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_packet_source_process_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*********************************************************************************
 * The Traffic source can produce unacknowledged and acknowledged MSDUs 
 * (MAC Service Dat Units = MAC Frame Payload) for CAP period.
**********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_source_init
 *
 * Description:	- initialize the process
 *				- read the values of source attributes
 *              - schedule a self interrupt that will indicate start time	
 *					for MSDU generation
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_source_init() {

	Objid own_id;	/* Object ID of the surrounding processor or queue */
	Objid traffic_source_comp_id; 
	Objid traffic_source_id;
	char device_mode[20];	/* mode of the device: PAN Coordinator or End Device */
	
	/* Stack tracing enrty point */
	FIN(wpan_source_init);

	
	/* obtain self object ID of the surrounding processor or queue */
	own_id = op_id_self ();

	/* obtain object ID of the parent object (node) */
	parent_id = op_topo_parent (own_id);
	
	/* get the value to check if this node is PAN coordinator or not */
	op_ima_obj_attr_get (parent_id, "Device Mode", device_mode);
	
	/* get the name of the node */
	op_ima_obj_attr_get (parent_id, "name", node_name);
	
	/* get destination MAC address */
	op_ima_obj_attr_get (own_id, "Destination MAC Address", &dest_mac_address); 	
	
	op_ima_obj_attr_get (parent_id, "Enable Logging", &enable_log);	
	
	op_ima_obj_attr_get (own_id, "Acknowledged Traffic Parameters", &traffic_source_id); 
	traffic_source_comp_id = op_topo_child (traffic_source_id, OPC_OBJTYPE_GENERIC, 0);
	
	/* Read the values of the ack-MSDU generation parameters, i.e. the attribute values of the surrounding module. */
	op_ima_obj_attr_get (traffic_source_comp_id, "MSDU Interarrival Time", ack_msdu_interarrival_dist_str);
	op_ima_obj_attr_get (traffic_source_comp_id, "MSDU Size",              ack_msdu_size_dist_str);
	op_ima_obj_attr_get (traffic_source_comp_id, "Start Time",             &ack_start_time);
	op_ima_obj_attr_get (traffic_source_comp_id, "Stop Time",              &ack_stop_time);	
		
	
	op_ima_obj_attr_get (own_id, "Unacknowledged Traffic Parameters", &traffic_source_id); 
	traffic_source_comp_id = op_topo_child (traffic_source_id, OPC_OBJTYPE_GENERIC, 0);
	
	/* Read the values of the unack-MSDU generation parameters, i.e. the attribute values of the surrounding module. */
	op_ima_obj_attr_get (traffic_source_comp_id, "MSDU Interarrival Time", unack_msdu_interarrival_dist_str);
	op_ima_obj_attr_get (traffic_source_comp_id, "MSDU Size",              unack_msdu_size_dist_str);
	op_ima_obj_attr_get (traffic_source_comp_id, "Start Time",             &unack_start_time);
	op_ima_obj_attr_get (traffic_source_comp_id, "Stop Time",              &unack_stop_time);
	
	/* if your are PAN Coordinator do not send packets itself */
	if ((strcmp(device_mode, "PAN Coordinator")==0) && (dest_mac_address==PAN_COORDINATOR_ADDRESS)) {
		ack_start_time = SC_INFINITE_TIME;
		unack_start_time = SC_INFINITE_TIME;
	}
	
	/* if the destination MAC address is broadcast do not send acknowledged packets */
	if ((dest_mac_address == BROADCAST_ADDRESS)&&(ack_start_time != SC_INFINITE_TIME)) {
		ack_start_time = SC_INFINITE_TIME;
		if (enable_log) {
			printf (" [Node %s] The acknowledged data cannot be generated, since the Destination MAC Adddress is set to BROADCAST. \n", node_name);
		}
	}
	
	
	/* Load the PDFs that will be used in computing the MSDU Interarrival Times and MSDU Sizes. */
	ack_msdu_interarrival_dist_ptr = oms_dist_load_from_string (ack_msdu_interarrival_dist_str);
	ack_msdu_size_dist_ptr       = oms_dist_load_from_string (ack_msdu_size_dist_str);
	
	/* Load the PDFs that will be used in computing the MSDUt Interarrival Times and MSDU Sizes. */
	unack_msdu_interarrival_dist_ptr = oms_dist_load_from_string (unack_msdu_interarrival_dist_str);
	unack_msdu_size_dist_ptr       = oms_dist_load_from_string (unack_msdu_size_dist_str);
	
	/* Make sure we have valid start and stop times, i.e. stop time is not earlier than start time.	*/
	if ((ack_stop_time <= ack_start_time) && (ack_stop_time != SC_INFINITE_TIME)) {
		/* Stop time is earlier than start time. Disable the source.	*/
		ack_start_time = SC_INFINITE_TIME;

		/* Display an appropriate warning.								*/
		op_prg_odb_print_major ("Warning from a Traffic source model:", 
								"Although the acknowledged generator is not disabled (start time is set to a finite value) a stop time that is not later than the start time is specified.",
								"Disabling the acknowledged generator.", OPC_NIL);
	}
	
	/* Make sure we have valid start and stop times, i.e. stop time is not earlier than start time.	*/
	if ((unack_stop_time <= unack_start_time) && (unack_stop_time != SC_INFINITE_TIME)) {
		/* Stop time is earlier than start time. Disable the source.	*/
		unack_start_time = SC_INFINITE_TIME;

		/* Display an appropriate warning.								*/
		op_prg_odb_print_major ("Warning from a Traffic source model:", 
								"Although the unacknowledged generator is not disabled (start time is set to a finite value) a stop time that is not later than the start time is specified.",
								"Disabling the unacknowledged generator.", OPC_NIL);
	}
	
	/* Schedule a self interrupt that will indicate transition to next state.	*/
	if ((ack_start_time == SC_INFINITE_TIME) && (unack_start_time == SC_INFINITE_TIME)) {
		op_intrpt_schedule_self (op_sim_time (), SC_STOP);	//DISABLED
	} else {
		op_intrpt_schedule_self (op_sim_time (), SC_START); //START
		
		/* In this case, also schedule the interrupt for starting of the MSDU generation */		
		if (ack_start_time != SC_INFINITE_TIME)
			op_intrpt_schedule_self (ack_start_time, SC_GENERATE_ACK);	//ACK_MSDU_GENERATE
		
		if (unack_start_time != SC_INFINITE_TIME)
			op_intrpt_schedule_self (unack_start_time, SC_GENERATE_UNACK);	//UNACK_MSDU_GENERATE	
		
		/* In this case, also schedule the interrupt when we will stop	generating */
		/* MSDUs, unless we are configured to run until the end of the simulation. */
		if ((ack_stop_time != SC_INFINITE_TIME) && (unack_stop_time != SC_INFINITE_TIME))	{
			op_intrpt_schedule_self (max_double (ack_stop_time, unack_stop_time), SC_STOP);
		}

	}	
	
	wpan_print_parameters ();
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	 wpan_print_parameters
 *
 * Description:	print the setting Traffic source parameters
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_print_parameters() {

	/* Stack tracing enrty point */	
	FIN(wpan_print_parameters);

	if (enable_log) {
		printf ("|----- [MSDU GENERATION - NODE \"%s\"] --------------------------------------|\n", node_name);
		printf (" Acknowledged Traffic parameters:\n");
		printf ("\t MSDU Interarival PDF : %s\n", ack_msdu_interarrival_dist_str);
		printf ("\t MSDU Size PDF        : %s\n", ack_msdu_size_dist_str);
		if (ack_start_time == -1) {
			printf ("\t Start time           : Infinity \n");
		}
		else {
			printf ("\t Start time           : %f\n", ack_start_time);
		}
		if (ack_stop_time == -1) {
			printf ("\t Stop time            : Infinity \n");
		}
		else {
			printf ("\t Stop time            : %f\n", ack_stop_time);
		}
		printf (" Unacknowledged Traffic parameters:\n");
		printf ("\t MSDU Interarival PDF : %s\n", unack_msdu_interarrival_dist_str);
		printf ("\t MSDU Size PDF        : %s\n", unack_msdu_size_dist_str);
		if (unack_start_time == -1) {
			printf ("\t Start time           : Infinity \n");
		}
		else {
			printf ("\t Start time           : %f\n", unack_start_time);
		}
		if (unack_stop_time == -1) {
			printf ("\t Stop time            : Infinity \n");
		}
		else {
			printf ("\t Stop time            : %f\n", unack_stop_time);
		}
		if (dest_mac_address == -1) {
			printf (" Destination MAC Address : PAN_coordinator \n");
		}
		else if (dest_mac_address == 0xFFFF) {
			printf (" Destination MAC Address : Broadcast - %d (%#X) \n", dest_mac_address, dest_mac_address);
		}
		else {
			printf (" Destination MAC Address : %d (%#X)\n", dest_mac_address, dest_mac_address);
		}
		printf ("|-----------------------------------------------------------------------------|\n\n");
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_ack_traffic_generate
 *
 * Description:	creates a MSDU requiring acknowledge based on the MSDU generation		
 *				 specifications of the source model and sends it to the lower layer.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_ack_traffic_generate() {
	
	Packet*	msdu_ptr;
	int	msdu_size; /* size in bits */
	double next_intarr_time;	/*  interarrival time of next MSDU */
	double abs_next_intarr_time; /* absolute interarrival time of next MSDU */

	/* Stack tracing enrty point */
	FIN (wpan_ack_traffic_generate);
	
	/* Generate a MSDU size outcome.		*/
	msdu_size = (int) ceil (oms_dist_outcome (ack_msdu_size_dist_ptr));
	
	/* 0 <= packet_size <= aMaxMACFrameSize_Bits (=(aMaxPHYPacketSize_Bits-MAC_HEADER_SIZE)) */
	if (msdu_size > aMaxMACFrameSize_Bits)
		msdu_size = aMaxMACFrameSize_Bits;	/* The size of generated MSDU is bigger than the maximum - the size is set to the maximum. */
		
	if (msdu_size < 0)
		msdu_size = 0;
	
	/* We produce unformatted packets. Create one.	*/
	msdu_ptr = op_pk_create (msdu_size);
	
	/* schedule next MSDU generation */
	next_intarr_time = oms_dist_outcome (ack_msdu_interarrival_dist_ptr);

	/* Make sure that interarrival time is not negative. In that case it will be set to 0. */
	if (next_intarr_time <0)
		next_intarr_time = 0.0;

	abs_next_intarr_time = op_sim_time () + next_intarr_time;
	
	/* Update the packet generation statistics.			*/
	op_stat_write (ack_msdus_sent_hndl, 1.0);
	op_stat_write (ack_msdus_sent_hndl, 0.0);
	op_stat_write (ack_bits_sent_hndl, (double) msdu_size);
	op_stat_write (ack_bits_sent_hndl, 0.0);
	op_stat_write (ack_bits_sent_hndlG, (double) msdu_size);
	op_stat_write (ack_bits_sent_hndlG, 0.0);
	op_stat_write (ack_msdu_size_hndl, (double) msdu_size);
	op_stat_write (ack_msdu_interarrival_time_hndl, next_intarr_time);
	op_stat_write (ack_msdus_hndl, 1.0);
	op_stat_write (ack_msdus_hndlG, 1.0);		
	
	app_sent_msdu_bits = app_sent_msdu_bits + (msdu_size/1000.0);	
	app_sent_msdu_nbr = app_sent_msdu_nbr + 1;
	
	/* send the MSDU via the stream to the lower layer.	*/
	op_pk_send (msdu_ptr, STRM_FROM_ACK_TO_MAC);
	
	if (enable_log) {
		printf (" [Node %s] t= %f -> Acknowledged MSDU (size = %d bits) was generated and sent to MAC layer.\n", node_name, op_sim_time(), msdu_size);
	}
	
	if ((abs_next_intarr_time <= ack_stop_time) || (ack_stop_time == SC_INFINITE_TIME)) {
		ack_next_msdu_evh = op_intrpt_schedule_self (abs_next_intarr_time, SC_GENERATE_ACK);
		
		if (enable_log) {
			printf ("\t Next Acknowledged MSDU will be generated at %f\n\n", abs_next_intarr_time);
		}
	}
		
	/* Stack tracing exit point */
	FOUT;

}

/*--------------------------------------------------------------------------------
 * Function:	wpan_unack_traffic_generate
 *
 * Description:	creates a MSDU based on the MSDU generation		
 *				 specifications of the source model and sends it to the lower layer.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_unack_traffic_generate() {

	Packet*	msdu_ptr;
	int	msdu_size; /* size in bits */
	double next_intarr_time;	/* interarrival time of next MSDU */
	double abs_next_intarr_time; /* absolute interarrival time of next MSDU */

	/* Stack tracing enrty point */
	FIN (wpan_unack_traffic_generate);
	
	/* Generate a MSDU size outcome.					*/
	msdu_size = (int) ceil (oms_dist_outcome (unack_msdu_size_dist_ptr));
	
	/* 0 <= packet_size <= aMaxMACFrameSize_Bits (=(aMaxPHYPacketSize_Bits-MAC_HEADER_SIZE))*/
	if (msdu_size > aMaxMACFrameSize_Bits)
		msdu_size = aMaxMACFrameSize_Bits;	/* The size of generated MSDU is bigger than the maximum - the size is set to the maximum. */
		
	if (msdu_size < 0)
		msdu_size = 0;
	
	/* We produce unformatted packets. Create one.	*/
	msdu_ptr = op_pk_create (msdu_size);
	
	/* schedule next MSDU generation */
	next_intarr_time = oms_dist_outcome (unack_msdu_interarrival_dist_ptr);

	/* Make sure that interarrival time is not negative. In that case it will be set to 0. */
	if (next_intarr_time <0)
		next_intarr_time = 0.0;

	abs_next_intarr_time = op_sim_time () + next_intarr_time;

	/* Update the packet generation statistics.			*/
	op_stat_write (unack_msdus_sent_hndl, 1.0);
	op_stat_write (unack_msdus_sent_hndl, 0.0);
	op_stat_write (unack_bits_sent_hndl, (double) msdu_size);
	op_stat_write (unack_bits_sent_hndl, 0.0);
	op_stat_write (unack_bits_sent_hndlG, (double) msdu_size);
	op_stat_write (unack_bits_sent_hndlG, 0.0);
	op_stat_write (unack_msdu_size_hndl, (double) msdu_size);
	op_stat_write (unack_msdu_interarrival_time_hndl, next_intarr_time);
	op_stat_write (unack_msdus_hndl, 1.0);
	op_stat_write (unack_msdus_hndlG, 1.0);
	
	app_sent_msdu_bits = app_sent_msdu_bits + (msdu_size/1000.0);
	app_sent_msdu_nbr = app_sent_msdu_nbr + 1;
	
	/* Send the MSDU via the stream to the lower layer.	*/
	op_pk_send (msdu_ptr, STRM_FROM_UNACK_TO_MAC);
	
	if (enable_log) {
		printf (" [Node %s] t= %f -> Unacknowledged MSDU (size = %d bits) was generated and sent to MAC layer.\n", node_name, op_sim_time(), msdu_size);	
	}
	
	if ((abs_next_intarr_time <= unack_stop_time) || (unack_stop_time == SC_INFINITE_TIME)) {
		unack_next_msdu_evh = op_intrpt_schedule_self (abs_next_intarr_time, SC_GENERATE_UNACK);
		
		if (enable_log) {
			printf ("\t Next Unacknowledged MSDU will be generated at %f\n\n", abs_next_intarr_time);
		}
	}

	/* Stack tracing exit point */
	FOUT;

}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wpan_packet_source_process (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wpan_packet_source_process_init (int * init_block_ptr);
	void _op_wpan_packet_source_process_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wpan_packet_source_process_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wpan_packet_source_process_alloc (VosT_Obtype, int);
	void _op_wpan_packet_source_process_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wpan_packet_source_process (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_packet_source_process ());

		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */


		FSM_ENTER ("wpan_packet_source_process")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (0, "idle", state0_enter_exec, "wpan_packet_source_process [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"wpan_packet_source_process")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "idle", "wpan_packet_source_process [idle exit execs]")


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [idle trans conditions]", state0_trans_conds)
			FSM_INIT_COND (START)
			FSM_TEST_COND (DISABLED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state0_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ;, "START", "", "idle", "generate", "tr_2", "wpan_packet_source_process [idle -> generate : START / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "DISABLED", "", "idle", "stop", "tr_3", "wpan_packet_source_process [idle -> stop : DISABLED / ]")
				FSM_CASE_TRANSIT (2, 0, state0_enter_exec, ;, "default", "", "idle", "idle", "tr_21", "wpan_packet_source_process [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (generate) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "generate", state1_enter_exec, "wpan_packet_source_process [generate enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"wpan_packet_source_process")


			/** state (generate) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "generate", "wpan_packet_source_process [generate exit execs]")


			/** state (generate) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [generate trans conditions]", state1_trans_conds)
			FSM_INIT_COND (STOP)
			FSM_TEST_COND (ACK_MSDU_GENERATE)
			FSM_TEST_COND (UNACK_MSDU_GENERATE)
			FSM_TEST_LOGIC ("generate")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 4, state4_enter_exec, ;, "STOP", "", "generate", "stop", "tr_9", "wpan_packet_source_process [generate -> stop : STOP / ]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "ACK_MSDU_GENERATE", "", "generate", "ACK", "tr_12", "wpan_packet_source_process [generate -> ACK : ACK_MSDU_GENERATE / ]")
				FSM_CASE_TRANSIT (2, 3, state3_enter_exec, ;, "UNACK_MSDU_GENERATE", "", "generate", "UNACK", "tr_17", "wpan_packet_source_process [generate -> UNACK : UNACK_MSDU_GENERATE / ]")
				}
				/*---------------------------------------------------------*/



			/** state (ACK) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "ACK", state2_enter_exec, "wpan_packet_source_process [ACK enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [ACK enter execs]", state2_enter_exec)
				{
				/* Generate and send an acknowledged MSDU (MAC Frame Payload) */
				wpan_ack_traffic_generate ();
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (ACK) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "ACK", "wpan_packet_source_process [ACK exit execs]")


			/** state (ACK) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "ACK", "generate", "tr_16", "wpan_packet_source_process [ACK -> generate : default / ]")
				/*---------------------------------------------------------*/



			/** state (UNACK) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "UNACK", state3_enter_exec, "wpan_packet_source_process [UNACK enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [UNACK enter execs]", state3_enter_exec)
				{
				/* Generate and send an unacknowledged MSDU (MAC Frame Payload) */
				wpan_unack_traffic_generate ();
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (UNACK) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "UNACK", "wpan_packet_source_process [UNACK exit execs]")


			/** state (UNACK) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "UNACK", "generate", "tr_18", "wpan_packet_source_process [UNACK -> generate : default / ]")
				/*---------------------------------------------------------*/



			/** state (stop) enter executives **/
			FSM_STATE_ENTER_UNFORCED (4, "stop", state4_enter_exec, "wpan_packet_source_process [stop enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [stop enter execs]", state4_enter_exec)
				{
				/* When we enter into the "stop" state, it is the time for us to	*/
				/* stop generating traffic. We simply cancel the generation of the	*/
				/* next MSDU (MAC frame payload) and go into a silent mode by not 
				/* scheduling anything else.							*/
				
				if (op_ev_valid (ack_next_msdu_evh) == OPC_TRUE)
					op_ev_cancel (ack_next_msdu_evh);
				
				if (op_ev_valid (unack_next_msdu_evh) == OPC_TRUE)
					op_ev_cancel (unack_next_msdu_evh);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (9,"wpan_packet_source_process")


			/** state (stop) exit executives **/
			FSM_STATE_EXIT_UNFORCED (4, "stop", "wpan_packet_source_process [stop exit execs]")


			/** state (stop) transition processing **/
			FSM_TRANSIT_MISSING ("stop")
				/*---------------------------------------------------------*/



			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (5, "init", "wpan_packet_source_process [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_packet_source_process [init enter execs]", state5_enter_exec)
				{
				/* Initialization */
				wpan_source_init ();
				
				/* Register the statistics that will be maintained by this model.	*/
				ack_bits_sent_hndl         		= op_stat_reg ("Traffic Source.Generated Acknowledged Traffic (bits/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				ack_msdus_sent_hndl         	= op_stat_reg ("Traffic Source.Generated Acknowledged Traffic (MSDUs/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				ack_msdu_size_hndl   			= op_stat_reg ("Traffic Source.Size of the Acknowledged MSDU (bits)",           OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				ack_msdu_interarrival_time_hndl	= op_stat_reg ("Traffic Source.Acknowledged MSDU Interarrival Time (secs)", 	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				ack_msdus_hndl  				= op_stat_reg ("Traffic Source.Number of Generated Acknowledged MSDUs", 		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				unack_bits_sent_hndl	  			= op_stat_reg ("Traffic Source.Generated Unacknowledged Traffic (bits/sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				unack_msdus_sent_hndl   			= op_stat_reg ("Traffic Source.Generated Unacknowledged Traffic (MSDUs/sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				unack_msdu_size_hndl    			= op_stat_reg ("Traffic Source.Size of the Unacknowledged MSDU (bits)",      	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				unack_msdu_interarrival_time_hndl  	= op_stat_reg ("Traffic Source.Unacknowledged MSDU Interarrival Time (secs)", 	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				unack_msdus_hndl  	  				= op_stat_reg ("Traffic Source.Number of Generated Unacknowledged MSDUs", 		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				ack_bits_sent_hndlG     = op_stat_reg ("Traffic Source.Generated Acknowledged Traffic (bits/sec)",		 OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				ack_msdus_hndlG  		= op_stat_reg ("Traffic Source.Number of Generated Acknowledged MSDUs", 		 OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				
				unack_bits_sent_hndlG   = op_stat_reg ("Traffic Source.Generated Unacknowledged Traffic (bits/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				unack_msdus_hndlG  	  	= op_stat_reg ("Traffic Source.Number of Generated Unacknowledged MSDUs", 			OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "init", "wpan_packet_source_process [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (0, state0_enter_exec, ;, "default", "", "init", "idle", "tr_20", "wpan_packet_source_process [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (5,"wpan_packet_source_process")
		}
	}




void
_op_wpan_packet_source_process_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wpan_packet_source_process_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wpan_packet_source_process_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wpan_packet_source_process_svar function. */
#undef ack_start_time
#undef ack_stop_time
#undef ack_msdu_interarrival_dist_ptr
#undef ack_msdu_size_dist_ptr
#undef ack_msdu_interarrival_dist_str
#undef ack_msdu_size_dist_str
#undef unack_start_time
#undef unack_stop_time
#undef unack_msdu_interarrival_dist_ptr
#undef unack_msdu_size_dist_ptr
#undef unack_msdu_interarrival_dist_str
#undef unack_msdu_size_dist_str
#undef dest_mac_address
#undef node_name
#undef parent_id
#undef enable_log
#undef ack_bits_sent_hndl
#undef ack_msdus_sent_hndl
#undef ack_msdu_size_hndl
#undef ack_msdu_interarrival_time_hndl
#undef ack_bits_sent_hndlG
#undef ack_msdus_hndl
#undef ack_msdus_hndlG
#undef unack_bits_sent_hndl
#undef unack_msdus_sent_hndl
#undef unack_msdu_size_hndl
#undef unack_msdu_interarrival_time_hndl
#undef unack_bits_sent_hndlG
#undef unack_msdus_hndl
#undef unack_msdus_hndlG
#undef ack_next_msdu_evh
#undef unack_next_msdu_evh

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wpan_packet_source_process_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wpan_packet_source_process_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_packet_source_process)",
		sizeof (wpan_packet_source_process_state));
	*init_block_ptr = 10;

	FRET (obtype)
	}

VosT_Address
_op_wpan_packet_source_process_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_packet_source_process_state * ptr;
	FIN_MT (_op_wpan_packet_source_process_alloc (obtype))

	ptr = (wpan_packet_source_process_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wpan_packet_source_process [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_packet_source_process_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_packet_source_process_state		*prs_ptr;

	FIN_MT (_op_wpan_packet_source_process_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_packet_source_process_state *)gen_ptr;

	if (strcmp ("ack_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_start_time);
		FOUT
		}
	if (strcmp ("ack_stop_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_stop_time);
		FOUT
		}
	if (strcmp ("ack_msdu_interarrival_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdu_interarrival_dist_ptr);
		FOUT
		}
	if (strcmp ("ack_msdu_size_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdu_size_dist_ptr);
		FOUT
		}
	if (strcmp ("ack_msdu_interarrival_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ack_msdu_interarrival_dist_str);
		FOUT
		}
	if (strcmp ("ack_msdu_size_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ack_msdu_size_dist_str);
		FOUT
		}
	if (strcmp ("unack_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_start_time);
		FOUT
		}
	if (strcmp ("unack_stop_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_stop_time);
		FOUT
		}
	if (strcmp ("unack_msdu_interarrival_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdu_interarrival_dist_ptr);
		FOUT
		}
	if (strcmp ("unack_msdu_size_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdu_size_dist_ptr);
		FOUT
		}
	if (strcmp ("unack_msdu_interarrival_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->unack_msdu_interarrival_dist_str);
		FOUT
		}
	if (strcmp ("unack_msdu_size_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->unack_msdu_size_dist_str);
		FOUT
		}
	if (strcmp ("dest_mac_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->dest_mac_address);
		FOUT
		}
	if (strcmp ("node_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->node_name);
		FOUT
		}
	if (strcmp ("parent_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->parent_id);
		FOUT
		}
	if (strcmp ("enable_log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->enable_log);
		FOUT
		}
	if (strcmp ("ack_bits_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_bits_sent_hndl);
		FOUT
		}
	if (strcmp ("ack_msdus_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdus_sent_hndl);
		FOUT
		}
	if (strcmp ("ack_msdu_size_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdu_size_hndl);
		FOUT
		}
	if (strcmp ("ack_msdu_interarrival_time_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdu_interarrival_time_hndl);
		FOUT
		}
	if (strcmp ("ack_bits_sent_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_bits_sent_hndlG);
		FOUT
		}
	if (strcmp ("ack_msdus_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdus_hndl);
		FOUT
		}
	if (strcmp ("ack_msdus_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_msdus_hndlG);
		FOUT
		}
	if (strcmp ("unack_bits_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_bits_sent_hndl);
		FOUT
		}
	if (strcmp ("unack_msdus_sent_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdus_sent_hndl);
		FOUT
		}
	if (strcmp ("unack_msdu_size_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdu_size_hndl);
		FOUT
		}
	if (strcmp ("unack_msdu_interarrival_time_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdu_interarrival_time_hndl);
		FOUT
		}
	if (strcmp ("unack_bits_sent_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_bits_sent_hndlG);
		FOUT
		}
	if (strcmp ("unack_msdus_hndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdus_hndl);
		FOUT
		}
	if (strcmp ("unack_msdus_hndlG" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_msdus_hndlG);
		FOUT
		}
	if (strcmp ("ack_next_msdu_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ack_next_msdu_evh);
		FOUT
		}
	if (strcmp ("unack_next_msdu_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->unack_next_msdu_evh);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

